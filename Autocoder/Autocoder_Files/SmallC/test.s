     ****************************************************************
     ***  test.s
     ***  Generated by Small-C Compiler on 28-Mar-2015 7:25:43 PM
     ****************************************************************
     ****************************************************************

     READ      EQU  001                * Read area
     PUNCH     EQU  101                * Punch area
     PRINT     EQU  201                * Print area
     
     PRCPOS    DCW  000                * char position in print area
     PUCPOS    DCW  000                * char position in punch area
     PUNSIZ    DCW  @080@              * Size of punch area
     PRTSIZ    DCW  @132@              * Size of print area
     EOS       DCW  @'@                * End Of String char
     EOL       DCW  @;@                * End Of Line char

               ORG  87
     X1        DSA  0                  * INDEX REGISTER 1
               ORG  92
     X2        DSA  0                  * INDEX REGISTER 2
               ORG  97
     X3        DSA  0                  * INDEX REGISTER 3
     
     * I need a single digit flag - should I replace this with a DA?
     RF        EQU  340
     
     ****************************************************************
     
     * GLOBAL/STATIC DATA AND VARIABLES

               ORG  600                * seed
               DCW  @69105@

               ORG  605                * CONST_STR_LITERAL-1
               DCW  @0@
               DCW  @1@
               DCW  @2@
               DCW  @3@
               DCW  @4@
               DCW  @5@
               DCW  @6@
               DCW  @7@
               DCW  @8@
               DCW  @9@
               DCW  @A@
               DCW  @B@
               DCW  @C@
               DCW  @D@
               DCW  @E@
               DCW  @F@
               DCW  @'@

               ORG  622                * __putchar_pos
               DCW  @201@

               ORG  625                * __putchar_last
               DCW  @200@

               ORG  628                * __getCharPosition
               DCW  @081@

               ORG  631                * c1
               DCW  @634@

               ORG  634                * CONST_STR_LITERAL-8
               DCW  @1@
               DCW  @2@
               DCW  @3@
               DCW  @4@
               DCW  @'@

               ORG  639                * a1
               DCW  @00000@
               DCW  @00000@
               DCW  @00000@
               DCW  @00000@
               DCW  @00000@
               DCW  @00000@
               DCW  @00000@
               DCW  @00000@
               DCW  @00000@
               DCW  @00000@

               ORG  689                * d1
               DCW  @692@

               ORG  692                * CONST_STR_LITERAL-9
               DCW  @5@
               DCW  @6@
               DCW  @7@
               DCW  @8@
               DCW  @'@

               ORG  697                * b1
               DCW  @'@
               DCW  @'@
               DCW  @'@
               DCW  @'@
               DCW  @'@
               DCW  @'@
               DCW  @'@
               DCW  @'@
               DCW  @'@
               DCW  @'@

               ORG  707                * e1
               DCW  @710@

               ORG  710                * CONST_STR_LITERAL-10
               DCW  @9@
               DCW  @9@
               DCW  @9@
               DCW  @9@
               DCW  @'@

               ORG  715                * f1
               DCW  @00000@

               ORG  720                * g1
               DCW  @723@

               ORG  723                * CONST_STR_LITERAL-11
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @'@

               ORG  728                * h1
               DCW  @'@

               ORG  729                * i1
               DCW  @732@

               ORG  732                * CONST_STR_LITERAL-12
               DCW  @B@
               DCW  @B@
               DCW  @B@
               DCW  @B@
               DCW  @'@

               ORG  737                * p1
               DCW  @000@

               ORG  740                * q1
               DCW  @743@

               ORG  743                * CONST_STR_LITERAL-13
               DCW  @C@
               DCW  @C@
               DCW  @C@
               DCW  @C@
               DCW  @'@

               ORG  748                * r1
               DCW  @000@

               ORG  751                * s1
               DCW  @754@

               ORG  754                * CONST_STR_LITERAL-14
               DCW  @Z@
               DCW  @Z@
               DCW  @Z@
               DCW  @Z@
               DCW  @'@

               ORG  759                * CONST_STR_LITERAL-15
               DCW  @C@
               DCW  @1@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  767                * CONST_STR_LITERAL-16
               DCW  @A@
               DCW  @1@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  775                * CONST_STR_LITERAL-17
               DCW  @P@
               DCW  @1@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  783                * CONST_STR_LITERAL-18
               DCW  @R@
               DCW  @1@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  791                * CONST_STR_LITERAL-19
               DCW  @D@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  798                * CONST_STR_LITERAL-20
               DCW  @*@
               DCW  @D@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

     * START POSITION OF PROGRAM CODE
               ORG  806
     START     NOP                     * Program starts here

     * SETTING OF STACK POINTER (STACK GROWS UPWARD)
               SBR  X2,399             * X2 is the stack pointer
               MCW  X2,X3              * Copy X2 to X3

               B    LUDAAA             * Jump to function main
               H                       * Program executed. System halted.

     ********************************************************************************
     * Function : itoa
     ********************************************************************************
     LYAAAA    SBR  3+X3               * Save return address in register B to local frame (X3)
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LZAAAA:null]
               LCA  LWDAAA,9+X3        * Load *char 605 into memory 9+X3
               LCA  LXDAAA,14+X3       * Load int 1 into memory 14+X3
               MA   LYDAAA,X2          * Reserve 14 bytes of space on Stack
     * Assignment (start = str)
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  15992+X3,0+X2      * Load data 15992+X3 into Stack
     * Push (LAEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LAEAAA,0+X2        * Load data 006 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (start = str)
     * If [if ((value < 0) then [Block LABAAA:LZAAAA] else [if ((value == 0) then [Block LBBAAA:LZAAAA]]]
     * Less (<) (value < 0)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data 15997+X3 into Stack
               B    LDEAAA             * Jump to snippet clean_number
     * Constant (0 : LFEAAA)
     * Push (LFEAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LFEAAA,0+X2        * Load data 00000 into Stack
               B    LDEAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2      * Compare
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               MCW  LFEAAA,0+X2        * Set stack location to 0
               BL   LGEAAA             * Jump if less
               B    LHEAAA             * Jump to End
     LGEAAA    MCW  LXDAAA,0+X2        * Less: Set stack location to 1
     LHEAAA    NOP                     * End of Less
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LDBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LABAAA:LZAAAA]
     * Assignment ((*(str++)) = '-')
     * Constant ('-' : @-@)
     * Push (@-@:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  @-@,0+X2           * Load data - into Stack
     * PostIncrement (str++)
     * Push (LLEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LLEAAA,0+X2        * Load data I9B into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
               MA   LKEAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LMEAAA,X2          * Add -1 to X2
     * End Assignment ((*(str++)) = '-')
     * Assignment (value = (-value))
     * Negate (-value)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data 15997+X3 into Stack
               ZS   0+X2
               B    LDEAAA             * Jump to snippet clean_number
     * Push (LBEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data I9G into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LIEAAA,X2          * Add -5 to X2
     * End Assignment (value = (-value))
     LABAAA    NOP                     * Return
               BCE  LZAAAA,RF,R        * Jump back to caller
     * EndBlock [Block LABAAA:LZAAAA]
     ***************************************

               B    LEBAAA             * Jump when true
     LDBAAA    NOP                     * Executed when False
     * If [if ((value == 0) then [Block LBBAAA:LZAAAA]]
     * Equal (==) (value == 0)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data 15997+X3 into Stack
               B    LDEAAA             * Jump to snippet clean_number
     * Constant (0 : LFEAAA)
     * Push (LFEAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LFEAAA,0+X2        * Load data 00000 into Stack
               B    LDEAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2      * Compare
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Push (LFEAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LFEAAA,0+X2        * Load data 00000 into Stack
               BE   LNEAAA             * Jump if equal
               B    LOEAAA             * Jump to End
     LNEAAA    MCW  LXDAAA,0+X2        * Equal
     LOEAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LCBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LBBAAA:LZAAAA]
     * Assignment ((str[0]) = '0')
     * Constant ('0' : @0@)
     * Push (@0@:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  @0@,0+X2           * Load data 0 into Stack
     * SubScript (str[0])
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  15992+X3,0+X2      * Load data 15992+X3 into Stack
     * End SubScript (str[0])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LMEAAA,X2          * Add -1 to X2
     * End Assignment ((str[0]) = '0')
     * Assignment ((str[1]) = '\0')
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data EOS into Stack
     * SubScript (str[1])
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  15992+X3,0+X2      * Load data 15992+X3 into Stack
               A    LXDAAA,0+X2        * Add offset 1 to point element 1
     * End SubScript (str[1])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LMEAAA,X2          * Add -1 to X2
     * End Assignment ((str[1]) = '\0')
     * Local Variable (start : 6+X3)
     * Push (6+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data 6+X3 into Stack
     * Pop (15984+X3:3)
               LCA  0+X2,15984+X3      * Load data in Stack into memory at 15984+X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF             * PUT R into location RF
               B    LBBAAA             * Jump back to caller
     LBBAAA    NOP                     * Return
               BCE  LZAAAA,RF,R        * Jump back to caller
     * EndBlock [Block LBBAAA:LZAAAA]
     ***************************************

     LCBAAA    NOP                     * Executed when False
     LEBAAA    NOP                     * Executed when True
     * While [while ((exp <= (value / base))) [Block LFBAAA:LZAAAA] top:LGBAAA bottom:LHBAAA]
     LGBAAA    NOP                     * Top of the loop
     * LessOrEqual (<=) (exp <= (value / base))
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data 14+X3 into Stack
               B    LDEAAA             * Jump to snippet clean_number
     * Divide (value / base)
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  15989+X3,0+X2      * Load data 15989+X3 into Stack
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data 15997+X3 into Stack
               B    LQEAAA             * Jump to snippet SNIP_DIV
               MCW  0+X2,15995+X2      * copy stack location to stack location at offset -5
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               B    LDEAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2      * Compare
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               MCW  LXDAAA,0+X2        * Set stack location to 1
               BH   LWEAAA             * Jump if less or equal
               B    LXEAAA             * Jump to End
     LWEAAA    MCW  LFEAAA,0+X2        * Less or equal: Set stack location to 0
     LXEAAA    NOP                     * End of LessOrEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LHBAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LFBAAA:LZAAAA]
     * Assignment (exp = (exp * base))
     * Multiply (exp * base)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data 14+X3 into Stack
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  15989+X3,0+X2      * Load data 15989+X3 into Stack
               M    15995+X2,6+X2      * Multiply
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Push (LYDAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LYDAAA,0+X2        * Load data 014 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LIEAAA,X2          * Add -5 to X2
     * End Assignment (exp = (exp * base))
     LFBAAA    NOP                     * Return
               BCE  LZAAAA,RF,R        * Jump back to caller
     * EndBlock [Block LFBAAA:LZAAAA]
     ***************************************

               B    LGBAAA             * Jump to top
     LHBAAA    NOP                     * Bottom of the while loop

     * While [while (exp) [Block LIBAAA:LZAAAA] top:LJBAAA bottom:LKBAAA]
     LJBAAA    NOP                     * Top of the loop
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data 14+X3 into Stack
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LKBAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LIBAAA:LZAAAA]
     * Assignment ((*(str++)) = (digits[(value / exp)]))
     * SubScript (digits[(value / exp)])
     * Local Variable (digits : 9+X3)
     * Push (9+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  9+X3,0+X2          * Load data 9+X3 into Stack
     * Divide (value / exp)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data 14+X3 into Stack
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data 15997+X3 into Stack
               B    LQEAAA             * Jump to snippet SNIP_DIV
               MCW  0+X2,15995+X2      * copy stack location to stack location at offset -5
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Put raw index on the stack
     * Push (LXDAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data 00001 into Stack
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Stack top is now array index
               B    LYEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Stack top is location in array now
     * End SubScript (digits[(value / exp)])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * PostIncrement (str++)
     * Push (LLEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LLEAAA,0+X2        * Load data I9B into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
               MA   LKEAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LMEAAA,X2          * Add -1 to X2
     * End Assignment ((*(str++)) = (digits[(value / exp)]))
     * Assignment (value = (value % exp))
     * Modulo (%) (value % exp)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data 14+X3 into Stack
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data 15997+X3 into Stack
               B    LQEAAA             * Jump to snippet SNIP_DIV
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Push (LBEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data I9G into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LIEAAA,X2          * Add -5 to X2
     * End Assignment (value = (value % exp))
     * Assignment (exp = (exp / base))
     * Divide (exp / base)
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  15989+X3,0+X2      * Load data 15989+X3 into Stack
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data 14+X3 into Stack
               B    LQEAAA             * Jump to snippet SNIP_DIV
               MCW  0+X2,15995+X2      * copy stack location to stack location at offset -5
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Push (LYDAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LYDAAA,0+X2        * Load data 014 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LIEAAA,X2          * Add -5 to X2
     * End Assignment (exp = (exp / base))
     LIBAAA    NOP                     * Return
               BCE  LZAAAA,RF,R        * Jump back to caller
     * EndBlock [Block LIBAAA:LZAAAA]
     ***************************************

               B    LJBAAA             * Jump to top
     LKBAAA    NOP                     * Bottom of the while loop

     * Assignment ((*str) = '\0')
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data EOS into Stack
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  15992+X3,0+X2      * Load data 15992+X3 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LMEAAA,X2          * Add -1 to X2
     * End Assignment ((*str) = '\0')
     * Local Variable (start : 6+X3)
     * Push (6+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data 6+X3 into Stack
     * Pop (15984+X3:3)
               LCA  0+X2,15984+X3      * Load data in Stack into memory at 15984+X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF             * PUT R into location RF
               B    LZAAAA             * Jump back to caller
     LZAAAA    NOP                     * Return
               MA   LFFAAA,X2          * Reserve 14 bytes of space on Stack
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LZAAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : itoa
     ********************************************************************************

     ********************************************************************************
     * Function : strcpy
     ********************************************************************************
     LJAAAA    SBR  3+X3               * Save return address in register B to local frame (X3)
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LKAAAA:null]
               MA   LZDAAA,X2          * Reserve 3 bytes of space on Stack
     * While [while ((((*(dest++)) = (*(src++))) != '\0')) [] top:LLAAAA bottom:LMAAAA]
     LLAAAA    NOP                     * Top of the loop
     * NotEqual (!=) (((*(dest++)) = (*(src++))) != '\0')
     * Assignment ((*(dest++)) = (*(src++)))
     * DereferenceExpression (*(src++))
     * PostIncrement (src++)
     * Push (LIFAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LIFAAA,0+X2        * Load data I9D into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
               MA   LKEAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * End DereferenceExpression (*(src++))
     * PostIncrement (dest++)
     * Push (LBEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data I9G into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
               MA   LKEAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
               LCA  0+X2,0+X1          * Load data in Stack into X1
     * End Assignment ((*(dest++)) = (*(src++)))
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data EOS into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LXDAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data 00001 into Stack
               BE   LGFAAA             * Jump if equal
               B    LHFAAA             * Jump to End
     LGFAAA    MCW  LFEAAA,0+X2        * Equal: Set stack location to 0
     LHFAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LMAAAA,5+X2,       * Jump to bottom
               B    LLAAAA             * Jump to top
     LMAAAA    NOP                     * Bottom of the while loop

     LKAAAA    NOP                     * Return
               MA   LBEAAA,X2          * Reserve 3 bytes of space on Stack
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LKAAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : strcpy
     ********************************************************************************

     ********************************************************************************
     * Function : putchar
     ********************************************************************************
     LLBAAA    SBR  3+X3               * Save return address in register B to local frame (X3)
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LMBAAA:null]
               MA   LZDAAA,X2          * Reserve 3 bytes of space on Stack
     * If [if ((c != '\n') then [Block LNBAAA:LMBAAA] else [Block LOBAAA:LMBAAA]]
     * NotEqual (!=) (c != '\n')
     * Parameter Variable (c : 15997+X3)
     * Push (15997+X3:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  15997+X3,0+X2      * Load data 15997+X3 into Stack
     * Constant ('\n' : EOL)
     * Push (EOL:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  EOL,0+X2           * Load data EOL into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LXDAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data 00001 into Stack
               BE   LJFAAA             * Jump if equal
               B    LKFAAA             * Jump to End
     LJFAAA    MCW  LFEAAA,0+X2        * Equal: Set stack location to 0
     LKFAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LSBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LNBAAA:LMBAAA]
     * Assignment ((*(__putchar_pos++)) = c)
     * Parameter Variable (c : 15997+X3)
     * Push (15997+X3:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  15997+X3,0+X2      * Load data 15997+X3 into Stack
     * PostIncrement (__putchar_pos++)
     * Push (LLFAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LLFAAA,0+X2        * Load data 624 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
               MA   LKEAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LMEAAA,X2          * Add -1 to X2
     * End Assignment ((*(__putchar_pos++)) = c)
     LNBAAA    NOP                     * Return
               BCE  LMBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LNBAAA:LMBAAA]
     ***************************************

               B    LTBAAA             * Jump when true
     LSBAAA    NOP                     * Executed when False

     ***************************************
     * BeginBlock [Block LOBAAA:LMBAAA]
     * While [while ((((int) __putchar_last) >= ((int) __putchar_pos))) [Block LPBAAA:LOBAAA] top:LQBAAA bottom:LRBAAA]
     LQBAAA    NOP                     * Top of the loop
     * GreaterOrEqual (>=) ((((int) __putchar_last) >= ((int) __putchar_pos))
     * Static Variable (__putchar_last : 627)
     * Push (627:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  627,0+X2           * Load data 627 into Stack
     * Cast Pointer(__putchar_last) to Number
               B    LMFAAA             * Jump to snippet pointer_to_number
               B    LDEAAA             * Jump to snippet clean_number
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  624,0+X2           * Load data 624 into Stack
     * Cast Pointer(__putchar_pos) to Number
               B    LMFAAA             * Jump to snippet pointer_to_number
               B    LDEAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2      * Compare
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               MCW  LXDAAA,0+X2        * Set stack location to 1
               BL   LVFAAA             * Jump if greater or equal
               B    LWFAAA             * Jump to End
     LVFAAA    MCW  LFEAAA,0+X2        * GreaterOrEqual: Set stack location to 0
     LWFAAA    NOP                     * End of GreaterOrEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LRBAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LPBAAA:LOBAAA]
     * Assignment ((*(__putchar_last--)) = ' ')
     * Constant (' ' : @ @)
     * Push (@ @:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  @ @,0+X2           * Load data   into Stack
     * PostDecrement (__putchar_last--)
     * Push (LYFAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LYFAAA,0+X2        * Load data 627 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
               MA   LMEAAA,0+X1        * PostDecrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LMEAAA,X2          * Add -1 to X2
     * End Assignment ((*(__putchar_last--)) = ' ')
     LPBAAA    NOP                     * Return
               BCE  LOBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LPBAAA:LOBAAA]
     ***************************************

               B    LQBAAA             * Jump to top
     LRBAAA    NOP                     * Bottom of the while loop

     * Assignment (__putchar_last = __putchar_pos)
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  624,0+X2           * Load data 624 into Stack
     * Push (LYFAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LYFAAA,0+X2        * Load data 627 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (__putchar_last = __putchar_pos)
     * Assignment (__putchar_pos = 201)
     * Constant (201 : LZFAAA)
     * Push (LZFAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LZFAAA,0+X2        * Load data 201 into Stack
     * Push (LLFAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LLFAAA,0+X2        * Load data 624 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (__putchar_pos = 201)
     * Start asm block
               W    
     * End asm block
     LOBAAA    NOP                     * Return
               BCE  LMBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LOBAAA:LMBAAA]
     ***************************************

     LTBAAA    NOP                     * Executed when True
     * If [if ((__putchar_pos == 333) then [Block LUBAAA:LMBAAA]]
     * Equal (==) (__putchar_pos == 333)
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  624,0+X2           * Load data 624 into Stack
     * Constant (333 : LCGAAA)
     * Push (LCGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LCGAAA,0+X2        * Load data 333 into Stack
               C    0+X2,15997+X2      * Compare
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (LFEAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LFEAAA,0+X2        * Load data 00000 into Stack
               BE   LAGAAA             * Jump if equal
               B    LBGAAA             * Jump to End
     LAGAAA    MCW  LXDAAA,0+X2        * Equal
     LBGAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LVBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LUBAAA:LMBAAA]
     * Assignment (__putchar_last = __putchar_pos)
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  624,0+X2           * Load data 624 into Stack
     * Push (LYFAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LYFAAA,0+X2        * Load data 627 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (__putchar_last = __putchar_pos)
     * Assignment (__putchar_pos = 201)
     * Constant (201 : LZFAAA)
     * Push (LZFAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LZFAAA,0+X2        * Load data 201 into Stack
     * Push (LLFAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LLFAAA,0+X2        * Load data 624 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (__putchar_pos = 201)
     * Start asm block
               W    
     * End asm block
     LUBAAA    NOP                     * Return
               BCE  LMBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LUBAAA:LMBAAA]
     ***************************************

     LVBAAA    NOP                     * Executed when False
     LMBAAA    NOP                     * Return
               MA   LBEAAA,X2          * Reserve 3 bytes of space on Stack
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LMBAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : putchar
     ********************************************************************************

     ********************************************************************************
     * Function : main
     ********************************************************************************
     LUDAAA    SBR  3+X3               * Save return address in register B to local frame (X3)
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LVDAAA:null]
               LCA  LDGAAA,66+X3       * Load *char 200 into memory 66+X3
               LCA  LEGAAA,69+X3       * Load *int 643 into memory 69+X3
               MA   LFGAAA,X2          * Reserve 69 bytes of space on Stack
     * Assignment ((*d) = 123)
     * Constant (123 : LGGAAA)
     * Push (LGGAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LGGAAA,0+X2        * Load data 00123 into Stack
     * Local Variable (d : 69+X3)
     * Push (69+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  69+X3,0+X2         * Load data 69+X3 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LIEAAA,X2          * Add -5 to X2
     * End Assignment ((*d) = 123)
     * Function Call printf(CONST_STR_LITERAL-15, ((int) c1))
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * Static Variable (c1 : 633)
     * Push (633:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  633,0+X2           * Load data 633 into Stack
     * Cast Pointer(c1) to Number
               B    LMFAAA             * Jump to snippet pointer_to_number
     * Static Array (CONST_STR_LITERAL-15:char [8])
     * Push (LHGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LHGAAA,0+X2        * Load data 759 into Stack
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LPCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Function Call printf(CONST_STR_LITERAL-16, ((int) a1))
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * Static Array (a1:int [10])
     * Push (LEGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LEGAAA,0+X2        * Load data 643 into Stack
     * Cast Pointer(a1) to Number
               B    LMFAAA             * Jump to snippet pointer_to_number
     * Static Array (CONST_STR_LITERAL-16:char [8])
     * Push (LIGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LIGAAA,0+X2        * Load data 767 into Stack
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LPCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Function Call printf(CONST_STR_LITERAL-17, ((int) p1))
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * Static Variable (p1 : 739)
     * Push (739:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  739,0+X2           * Load data 739 into Stack
     * Cast Pointer(p1) to Number
               B    LMFAAA             * Jump to snippet pointer_to_number
     * Static Array (CONST_STR_LITERAL-17:char [8])
     * Push (LJGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LJGAAA,0+X2        * Load data 775 into Stack
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LPCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Function Call printf(CONST_STR_LITERAL-18, ((int) r1))
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * Static Variable (r1 : 750)
     * Push (750:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  750,0+X2           * Load data 750 into Stack
     * Cast Pointer(r1) to Number
               B    LMFAAA             * Jump to snippet pointer_to_number
     * Static Array (CONST_STR_LITERAL-18:char [8])
     * Push (LKGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LKGAAA,0+X2        * Load data 783 into Stack
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LPCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Function Call printf(CONST_STR_LITERAL-19, d)
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * Local Variable (d : 69+X3)
     * Push (69+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  69+X3,0+X2         * Load data 69+X3 into Stack
     * Static Array (CONST_STR_LITERAL-19:char [7])
     * Push (LLGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LLGAAA,0+X2        * Load data 791 into Stack
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LPCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Function Call printf(CONST_STR_LITERAL-20, (*d))
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * DereferenceExpression (*d)
     * Local Variable (d : 69+X3)
     * Push (69+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  69+X3,0+X2         * Load data 69+X3 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * End DereferenceExpression (*d)
     * Static Array (CONST_STR_LITERAL-20:char [8])
     * Push (LMGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LMGAAA,0+X2        * Load data 798 into Stack
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LPCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     LVDAAA    NOP                     * Return
               MA   LNGAAA,X2          * Reserve 69 bytes of space on Stack
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LVDAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : main
     ********************************************************************************

     ********************************************************************************
     * Function : printf
     ********************************************************************************
     LPCAAA    SBR  3+X3               * Save return address in register B to local frame (X3)
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LQCAAA:null]
               MA   LOGAAA,X2          * Reserve 11 bytes of space on Stack
     * Assignment (arg = ((*char) (( &cformat_str ) + 15997)))
     * Addition (( &cformat_str ) + 15997)
     * AddressOf ( &cformat_str )
     * Push (LBEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data I9G into Stack
               MA   X3,0+X2
     * Constant (15997 : LBEAAA)
     * Push (LBEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data I9G into Stack
               MA   0+X2,15997+X2      * Add
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (LAEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LAEAAA,0+X2        * Load data 006 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (arg = ((*char) (( &cformat_str ) + 15997)))
     * While [while (((c = (*(cformat_str++))) != '\0')) [Block LRCAAA:LQCAAA] top:LMDAAA bottom:LNDAAA]
     LMDAAA    NOP                     * Top of the loop
     * NotEqual (!=) ((c = (*(cformat_str++))) != '\0')
     * Assignment (c = (*(cformat_str++)))
     * DereferenceExpression (*(cformat_str++))
     * PostIncrement (cformat_str++)
     * Push (LBEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data I9G into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
               MA   LKEAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * End DereferenceExpression (*(cformat_str++))
     * Push (LRGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LRGAAA,0+X2        * Load data 007 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
               LCA  0+X2,0+X1          * Load data in Stack into X1
     * End Assignment (c = (*(cformat_str++)))
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data EOS into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LXDAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data 00001 into Stack
               BE   LPGAAA             * Jump if equal
               B    LQGAAA             * Jump to End
     LPGAAA    MCW  LFEAAA,0+X2        * Equal: Set stack location to 0
     LQGAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LNDAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LRCAAA:LQCAAA]
     * If [if ((c != '%') then [Block LSCAAA:LRCAAA] else [Block LTCAAA:LRCAAA]]
     * NotEqual (!=) (c != '%')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data 7+X3 into Stack
     * Constant ('%' : @%@)
     * Push (@%@:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  @%@,0+X2           * Load data % into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LXDAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data 00001 into Stack
               BE   LSGAAA             * Jump if equal
               B    LTGAAA             * Jump to End
     LSGAAA    MCW  LFEAAA,0+X2        * Equal: Set stack location to 0
     LTGAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LKDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LSCAAA:LRCAAA]
     * Function Call putchar(c)
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data 7+X3 into Stack
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LLBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     LSCAAA    NOP                     * Return
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LSCAAA:LRCAAA]
     ***************************************

               B    LLDAAA             * Jump when true
     LKDAAA    NOP                     * Executed when False

     ***************************************
     * BeginBlock [Block LTCAAA:LRCAAA]
     * Assignment (c = (*(cformat_str++)))
     * DereferenceExpression (*(cformat_str++))
     * PostIncrement (cformat_str++)
     * Push (LBEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data I9G into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
               MA   LKEAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * End DereferenceExpression (*(cformat_str++))
     * Push (LRGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LRGAAA,0+X2        * Load data 007 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LMEAAA,X2          * Add -1 to X2
     * End Assignment (c = (*(cformat_str++)))
     * If [if ((c == '%') then [Block LUCAAA:LTCAAA] else [if ((c == 'C') then [Block LVCAAA:LTCAAA] else [if ((c == 'S') then [Block LWCAAA:LTCAAA] else [if ((c == 'D') then [Block LXCAAA:LTCAAA] else [if ((c == 'P') then [Block LYCAAA:LTCAAA] else [Block LZCAAA:LTCAAA]]]]]]
     * Equal (==) (c == '%')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data 7+X3 into Stack
     * Constant ('%' : @%@)
     * Push (@%@:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  @%@,0+X2           * Load data % into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LFEAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LFEAAA,0+X2        * Load data 00000 into Stack
               BE   LVGAAA             * Jump if equal
               B    LWGAAA             * Jump to End
     LVGAAA    MCW  LXDAAA,0+X2        * Equal
     LWGAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LIDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LUCAAA:LTCAAA]
     * Function Call putchar('%')
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * Constant ('%' : @%@)
     * Push (@%@:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  @%@,0+X2           * Load data % into Stack
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LLBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     LUCAAA    NOP                     * Return
               BCE  LTCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LUCAAA:LTCAAA]
     ***************************************

               B    LJDAAA             * Jump when true
     LIDAAA    NOP                     * Executed when False
     * If [if ((c == 'C') then [Block LVCAAA:LTCAAA] else [if ((c == 'S') then [Block LWCAAA:LTCAAA] else [if ((c == 'D') then [Block LXCAAA:LTCAAA] else [if ((c == 'P') then [Block LYCAAA:LTCAAA] else [Block LZCAAA:LTCAAA]]]]]
     * Equal (==) (c == 'C')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data 7+X3 into Stack
     * Constant ('C' : @C@)
     * Push (@C@:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  @C@,0+X2           * Load data C into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LFEAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LFEAAA,0+X2        * Load data 00000 into Stack
               BE   LXGAAA             * Jump if equal
               B    LYGAAA             * Jump to End
     LXGAAA    MCW  LXDAAA,0+X2        * Equal
     LYGAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LGDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LVCAAA:LTCAAA]
     * Function Call putchar((*arg))
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * DereferenceExpression (*arg)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data 6+X3 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * End DereferenceExpression (*arg)
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LLBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Assignment (arg = (arg + 15999))
     * Addition (arg + 15999)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data 6+X3 into Stack
     * Constant (15999 : LMEAAA)
     * Push (LMEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LMEAAA,0+X2        * Load data I9I into Stack
               MA   0+X2,15997+X2      * Add
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (LAEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LAEAAA,0+X2        * Load data 006 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (arg = (arg + 15999))
     LVCAAA    NOP                     * Return
               BCE  LTCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LVCAAA:LTCAAA]
     ***************************************

               B    LHDAAA             * Jump when true
     LGDAAA    NOP                     * Executed when False
     * If [if ((c == 'S') then [Block LWCAAA:LTCAAA] else [if ((c == 'D') then [Block LXCAAA:LTCAAA] else [if ((c == 'P') then [Block LYCAAA:LTCAAA] else [Block LZCAAA:LTCAAA]]]]
     * Equal (==) (c == 'S')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data 7+X3 into Stack
     * Constant ('S' : @S@)
     * Push (@S@:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  @S@,0+X2           * Load data S into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LFEAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LFEAAA,0+X2        * Load data 00000 into Stack
               BE   LAHAAA             * Jump if equal
               B    LBHAAA             * Jump to End
     LAHAAA    MCW  LXDAAA,0+X2        * Equal
     LBHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LEDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LWCAAA:LTCAAA]
     * Function Call puts((*((**char) arg)))
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * DereferenceExpression (*((**char) arg))
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data 6+X3 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * End DereferenceExpression (*((**char) arg))
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LWBAAA             * Jump to function puts
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Assignment (arg = (arg + 15997))
     * Addition (arg + 15997)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data 6+X3 into Stack
     * Constant (15997 : LBEAAA)
     * Push (LBEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data I9G into Stack
               MA   0+X2,15997+X2      * Add
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (LAEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LAEAAA,0+X2        * Load data 006 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (arg = (arg + 15997))
     LWCAAA    NOP                     * Return
               BCE  LTCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LWCAAA:LTCAAA]
     ***************************************

               B    LFDAAA             * Jump when true
     LEDAAA    NOP                     * Executed when False
     * If [if ((c == 'D') then [Block LXCAAA:LTCAAA] else [if ((c == 'P') then [Block LYCAAA:LTCAAA] else [Block LZCAAA:LTCAAA]]]
     * Equal (==) (c == 'D')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data 7+X3 into Stack
     * Constant ('D' : @D@)
     * Push (@D@:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  @D@,0+X2           * Load data D into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LFEAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LFEAAA,0+X2        * Load data 00000 into Stack
               BE   LDHAAA             * Jump if equal
               B    LEHAAA             * Jump to End
     LDHAAA    MCW  LXDAAA,0+X2        * Equal
     LEHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LCDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LXCAAA:LTCAAA]
               MA   LRGAAA,X2          * Reserve 7 bytes of space on Stack
     * Function Call itoa((*((*int) arg)), a, 10)
     * Push (3)
               MA   LZDAAA,X2          * Add 3 to X2
     * Constant (10 : LGHAAA)
     * Push (LGHAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LGHAAA,0+X2        * Load data 00010 into Stack
     * Local Array (a:char [7])
     * Push (LHHAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LHHAAA,0+X2        * Load data 012 into Stack
               MA   X3,0+X2
     * DereferenceExpression (*((*int) arg))
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data 6+X3 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * End DereferenceExpression (*((*int) arg))
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LYAAAA             * Jump to function itoa
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Function Call puts(a)
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * Local Array (a:char [7])
     * Push (LHHAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LHHAAA,0+X2        * Load data 012 into Stack
               MA   X3,0+X2
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LWBAAA             * Jump to function puts
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Assignment (arg = (arg + 15995))
     * Addition (arg + 15995)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data 6+X3 into Stack
     * Constant (15995 : LIEAAA)
     * Push (LIEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LIEAAA,0+X2        * Load data I9E into Stack
               MA   0+X2,15997+X2      * Add
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (LAEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LAEAAA,0+X2        * Load data 006 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (arg = (arg + 15995))
     LXCAAA    NOP                     * Return
               MA   LIHAAA,X2          * Reserve 7 bytes of space on Stack
               BCE  LTCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LXCAAA:LTCAAA]
     ***************************************

               B    LDDAAA             * Jump when true
     LCDAAA    NOP                     * Executed when False
     * If [if ((c == 'P') then [Block LYCAAA:LTCAAA] else [Block LZCAAA:LTCAAA]]
     * Equal (==) (c == 'P')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data 7+X3 into Stack
     * Constant ('P' : @P@)
     * Push (@P@:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  @P@,0+X2           * Load data P into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LFEAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LFEAAA,0+X2        * Load data 00000 into Stack
               BE   LJHAAA             * Jump if equal
               B    LKHAAA             * Jump to End
     LJHAAA    MCW  LXDAAA,0+X2        * Equal
     LKHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LADAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LYCAAA:LTCAAA]
     * Assignment (addrP = arg)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data 6+X3 into Stack
     * Push (LMHAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LMHAAA,0+X2        * Load data 010 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (addrP = arg)
     * Assignment (addrC = (*addrP))
     * DereferenceExpression (*addrP)
     * Local Variable (addrP : 10+X3)
     * Push (10+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  10+X3,0+X2         * Load data 10+X3 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * End DereferenceExpression (*addrP)
     * Push (LOGAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LOGAAA,0+X2        * Load data 011 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LMEAAA,X2          * Add -1 to X2
     * End Assignment (addrC = (*addrP))
     * Function Call putchar(addrC)
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * Local Variable (addrC : 11+X3)
     * Push (11+X3:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  11+X3,0+X2         * Load data 11+X3 into Stack
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LLBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Start asm block
               W    
     * End asm block
     * Start asm block
               W    
     * End asm block
     * Start asm block
               W    
     * End asm block
     * Assignment (arg = (arg + 15999))
     * Addition (arg + 15999)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data 6+X3 into Stack
     * Constant (15999 : LMEAAA)
     * Push (LMEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LMEAAA,0+X2        * Load data I9I into Stack
               MA   0+X2,15997+X2      * Add
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (LAEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LAEAAA,0+X2        * Load data 006 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LBEAAA,X2          * Add -3 to X2
     * End Assignment (arg = (arg + 15999))
     LYCAAA    NOP                     * Return
               BCE  LTCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LYCAAA:LTCAAA]
     ***************************************

               B    LBDAAA             * Jump when true
     LADAAA    NOP                     * Executed when False

     ***************************************
     * BeginBlock [Block LZCAAA:LTCAAA]
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF             * PUT R into location RF
               B    LZCAAA             * Jump back to caller
     LZCAAA    NOP                     * Return
               BCE  LTCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LZCAAA:LTCAAA]
     ***************************************

     LBDAAA    NOP                     * Executed when True
     LDDAAA    NOP                     * Executed when True
     LFDAAA    NOP                     * Executed when True
     LHDAAA    NOP                     * Executed when True
     LJDAAA    NOP                     * Executed when True
     LTCAAA    NOP                     * Return
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LTCAAA:LRCAAA]
     ***************************************

     LLDAAA    NOP                     * Executed when True
     LRCAAA    NOP                     * Return
               BCE  LQCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LRCAAA:LQCAAA]
     ***************************************

               B    LMDAAA             * Jump to top
     LNDAAA    NOP                     * Bottom of the while loop

     LQCAAA    NOP                     * Return
               MA   LNHAAA,X2          * Reserve 11 bytes of space on Stack
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LQCAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : printf
     ********************************************************************************

     ********************************************************************************
     * Function : strlen
     ********************************************************************************
     LFAAAA    SBR  3+X3               * Save return address in register B to local frame (X3)
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LGAAAA:null]
               LCA  LOHAAA,8+X3        * Load int -1 into memory 8+X3
               MA   LPHAAA,X2          * Reserve 8 bytes of space on Stack
     * While [while (((str[(++len)]) != '\0')) [] top:LHAAAA bottom:LIAAAA]
     LHAAAA    NOP                     * Top of the loop
     * NotEqual (!=) ((str[(++len)]) != '\0')
     * SubScript (str[(++len)])
     * Parameter Variable (str : 15997+X3)
     * Push (15997+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  15997+X3,0+X2      * Load data 15997+X3 into Stack
     * PreIncrement((++len)
     * Push (LPHAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LPHAAA,0+X2        * Load data 008 into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
               A    LXDAAA,0+X1        * PreIncrement variable pointed by X1
     * Push (0+X1:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * Put raw index on the stack
     * Push (LXDAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data 00001 into Stack
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Stack top is now array index
               B    LYEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LBEAAA,X2          * Add -3 to X2
     * Stack top is location in array now
     * End SubScript (str[(++len)])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data EOS into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LXDAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data 00001 into Stack
               BE   LQHAAA             * Jump if equal
               B    LRHAAA             * Jump to End
     LQHAAA    MCW  LFEAAA,0+X2        * Equal: Set stack location to 0
     LRHAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LIAAAA,5+X2,       * Jump to bottom
               B    LHAAAA             * Jump to top
     LIAAAA    NOP                     * Bottom of the while loop

     * Local Variable (len : 8+X3)
     * Push (8+X3:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  8+X3,0+X2          * Load data 8+X3 into Stack
     * Pop (15994+X3:5)
               LCA  0+X2,15994+X3      * Load data in Stack into memory at 15994+X3
               MA   LIEAAA,X2          * Add -5 to X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF             * PUT R into location RF
               B    LGAAAA             * Jump back to caller
     LGAAAA    NOP                     * Return
               MA   LLEAAA,X2          * Reserve 8 bytes of space on Stack
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LGAAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : strlen
     ********************************************************************************

     ********************************************************************************
     * Function : genRand
     ********************************************************************************
     LBAAAA    SBR  3+X3               * Save return address in register B to local frame (X3)
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LCAAAA:null]
               MA   LZDAAA,X2          * Reserve 3 bytes of space on Stack
     * Assignment (seed = (((42 * seed) + 19) % 100000))
     * Modulo (%) (((42 * seed) + 19) % 100000)
     * Constant (100000 : LSHAAA)
     * Push (LSHAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LSHAAA,0+X2        * Load data 100000 into Stack
     * Addition ((42 * seed) + 19)
     * Multiply (42 * seed)
     * Constant (42 : LTHAAA)
     * Push (LTHAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LTHAAA,0+X2        * Load data 00042 into Stack
     * Static Variable (seed : 604)
     * Push (604:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  604,0+X2           * Load data 604 into Stack
               M    15995+X2,6+X2      * Multiply
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Constant (19 : LUHAAA)
     * Push (LUHAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LUHAAA,0+X2        * Load data 00019 into Stack
               A    0+X2,15995+X2      * Add
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               B    LQEAAA             * Jump to snippet SNIP_DIV
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     * Push (LVHAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LVHAAA,0+X2        * Load data 604 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LIEAAA,X2          * Add -5 to X2
     * End Assignment (seed = (((42 * seed) + 19) % 100000))
     * Static Variable (seed : 604)
     * Push (604:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  604,0+X2           * Load data 604 into Stack
     * Pop (15997+X3:5)
               LCA  0+X2,15997+X3      * Load data in Stack into memory at 15997+X3
               MA   LIEAAA,X2          * Add -5 to X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF             * PUT R into location RF
               B    LCAAAA             * Jump back to caller
     LCAAAA    NOP                     * Return
               MA   LBEAAA,X2          * Reserve 3 bytes of space on Stack
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LCAAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : genRand
     ********************************************************************************

     ********************************************************************************
     * Function : puts
     ********************************************************************************
     LWBAAA    SBR  3+X3               * Save return address in register B to local frame (X3)
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LXBAAA:null]
               MA   LZDAAA,X2          * Reserve 3 bytes of space on Stack
     * While [while (((*s) != '\0')) [Block LYBAAA:LXBAAA] top:LZBAAA bottom:LACAAA]
     LZBAAA    NOP                     * Top of the loop
     * NotEqual (!=) ((*s) != '\0')
     * DereferenceExpression (*s)
     * Parameter Variable (s : 15997+X3)
     * Push (15997+X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  15997+X3,0+X2      * Load data 15997+X3 into Stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * End DereferenceExpression (*s)
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data EOS into Stack
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Push (LXDAAA:5)
               MA   LCEAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data 00001 into Stack
               BE   LWHAAA             * Jump if equal
               B    LXHAAA             * Jump to End
     LWHAAA    MCW  LFEAAA,0+X2        * Equal: Set stack location to 0
     LXHAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
               BCE  LACAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LYBAAA:LXBAAA]
     * Function Call putchar((*(s++)))
     * Push (5)
               MA   LCEAAA,X2          * Add 5 to X2
     * DereferenceExpression (*(s++))
     * PostIncrement (s++)
     * Push (LBEAAA:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data I9G into Stack
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
               MA   LKEAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LBEAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LKEAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data 0+X1 into Stack
     * End DereferenceExpression (*(s++))
     * Push (X3:3)
               MA   LZDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data X3 into Stack
               MCW  X2,X3              * Copy X2 into X3
               B    LLBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data in Stack into memory at X3
               MA   LBEAAA,X2          * Add -3 to X2
     * Pop (1)
               MA   LMEAAA,X2          * Add -1 to X2
     * Pop (5)
               MA   LIEAAA,X2          * Add -5 to X2
     LYBAAA    NOP                     * Return
               BCE  LXBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LYBAAA:LXBAAA]
     ***************************************

               B    LZBAAA             * Jump to top
     LACAAA    NOP                     * Bottom of the while loop

     LXBAAA    NOP                     * Return
               MA   LBEAAA,X2          * Reserve 3 bytes of space on Stack
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LXBAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : puts
     ********************************************************************************
     ****************************************************************
     ** CLEAN NUMBER SNIPPET                                       **
     ****************************************************************
     
     * Normalizes the zone bits of a number, leaving either A=0B=0
     * for a positive or A=0B=1 for a negative
     LDEAAA    SBR  X1
     * Do nothing on either no zone bits or only a b zone bit
               BWZ  LEEAAA,0+X2,2
               BWZ  LEEAAA,0+X2,K
     * else clear the zone bits, as it is positive
               MZ   @ @,0+X2
     LEEAAA    B    0+X1
     
     ****************************************************************
     ****************************************************************  
     ** DIVISION SNIPPET                                           **
     ****************************************************************  
     
     LQEAAA    SBR  LREAAA+3           * SETUP RETURN ADDRESS
     * POP DIVIDEND
               MCW  0+X2, LSEAAA
               SBR  X2, 15995+X2

     * POP DIVISOR
               MCW  0+X2, LTEAAA
               SBR  X2, 15995+X2

               B    *+17
               
               DCW  @00000@                
               DC   @00000000000@        

               ZA   LSEAAA, *-7         * PUT DIVIDEND INTO WORKING BL
               D    LTEAAA, *-19        * DIVIDE
               MZ   *-22, *-21          * KILL THE ZONE BIT
               MZ   *-29, *-34          * KILL THE ZONE BIT
               MCW  *-41, LUEAAA        * PICK UP ANSWER
               SW   *-44                * SO I CAN PICKUP REMAINDER
               MCW  *-46, LVEAAA        * GET REMAINDER
               CW   *-55                * CLEAR THE WM
               MZ   LUEAAA-1, LUEAAA    * CLEANUP QUOTIENT BITZONE
               MZ   LVEAAA-1, LVEAAA    * CLEANUP REMAINDER BITZONE
               
     * PUSH REMAINDER
               SBR  X2, 5+X2
               SW   15996+X2
               MCW  LVEAAA, 0+X2
               
     * PUSH QUOTIENT
               SBR  X2, 5+X2
               SW   15996+X2
               MCW  LUEAAA, 0+X2

     LREAAA    B    000                 * JUMP BACK
               
     LTEAAA    DCW  00000               * DIVISOR
     LSEAAA    DCW  00000               * DIVIDEND
     LUEAAA    DCW  00000               * QUOTIENT
     LVEAAA    DCW  00000               * REMAINDER

     ****************************************************************
 
     ****************************************************************
     ** CAST NUMBER TO POINTER SNIPPET                             **
     ****************************************************************
     
     LYEAAA    SBR  X1
     * Casts a 5-digit number to a 3-digit address
     * make a copy of the top of the stack
               SW   15998+X2
               LCA  0+X2,3+X2
               CW   15998+X2
     * zero out the zone bits of our copy
               MZ   @0@,3+X2
               MZ   @0@,2+X2
               MZ   @0@,1+X2
     * set the low-order digit's zone bits
               C    @04000@,0+X2
               BL   LBFAAA
               C    @08000@,0+X2
               BL   LAFAAA
               C    @12000@,0+X2
               BL   LZEAAA
               S    @12000@,0+X2
               MZ   @A@,3+X2
               B    LBFAAA
     LZEAAA    S    @08000@,0+X2
               MZ   @I@,3+X2
               B    LBFAAA
     LAFAAA    S    @04000@,0+X2
               MZ   @S@,3+X2
     * For some reason the zone bits get set - it still works though.
     LBFAAA    C    @01000@,0+X2
               BL   LEFAAA
               C    @02000@,0+X2
               BL   LDFAAA
               C    @03000@,0+X2
               BL   LCFAAA
               MZ   @A@,1+X2
               B    LEFAAA
     LCFAAA    MZ   @I@,1+X2
               B    LEFAAA
     LDFAAA    MZ   @S@,1+X2
     LEFAAA    LCA  3+X2,15998+X2
               SBR  X2,15998+X2
               B    0+X1
               
     ****************************************************************
     
     ****************************************************************
     ** CAST POINTER TO NUMBER SNIPPET                             **
     ****************************************************************
     
     LMFAAA    SBR  X1
     * Casts a 3-digit address to a 5-digit number
     * Make room on the stack for an int
               MA   @002@,X2
     * make a copy of the top of the stack
               LCA  15998+X2,3+X2
     * Now zero out the top of the stack
               LCA  @00000@,0+X2
     * Now copy back, shifted over 2 digits
               MCW  3+X2,0+X2
     * Now zero out the zone bits on the stack
               MZ   @0@,0+X2
               MZ   @0@,15999+X2
               MZ   @0@,15998+X2
     * check the high-order digit's zone bits
               BWZ  LNFAAA,1+X2,S
               BWZ  LOFAAA,1+X2,K
               BWZ  LPFAAA,1+X2,B
               B    LQFAAA
     LNFAAA    A    @01000@,0+X2
               B    LQFAAA
     LOFAAA    A    @02000@,0+X2
               B    LQFAAA
     LPFAAA    A    @03000@,0+X2
     LQFAAA    BWZ  LRFAAA,3+X2,S
               BWZ  LSFAAA,3+X2,K
               BWZ  LTFAAA,3+X2,B
               B    LUFAAA
     LRFAAA    A    @04000@,0+X2
               B    LUFAAA
     LSFAAA    A    @08000@,0+X2
               B    LUFAAA
     LTFAAA    A    @12000@,0+X2
     LUFAAA    B    0+X1

     ****************************************************************

     LAEAAA    DCW  @006@              * Pointer 0
     LBEAAA    DCW  @I9G@              * Pointer 0
     LCEAAA    DCW  @005@              * Pointer 0
     LCGAAA    DCW  @333@              * Pointer 0
     LCHAAA    DCW  @S@                * Value S
     LDGAAA    DCW  @200@              * Pointer 0
     LEGAAA    DCW  @643@              * Pointer 0
     LFEAAA    DCW  @00000@            * Value 00000
     LFFAAA    DCW  @I8F@              * Pointer 0
     LFGAAA    DCW  @069@              * Pointer 0
     LFHAAA    DCW  @D@                * Value D
     LGGAAA    DCW  @00123@            * Value 00123
     LGHAAA    DCW  @00010@            * Value 00010
     LHGAAA    DCW  @759@              * Pointer 0
     LHHAAA    DCW  @012@              * Pointer 0
     LIEAAA    DCW  @I9E@              * Pointer 0
     LIFAAA    DCW  @I9D@              * Pointer 0
     LIGAAA    DCW  @767@              * Pointer 0
     LIHAAA    DCW  @I9C@              * Pointer 0
     LJEAAA    DCW  @-@                * Value -
     LJGAAA    DCW  @775@              * Pointer 0
     LKEAAA    DCW  @001@              * Pointer 0
     LKGAAA    DCW  @783@              * Pointer 0
     LLEAAA    DCW  @I9B@              * Pointer 0
     LLFAAA    DCW  @624@              * Pointer 0
     LLGAAA    DCW  @791@              * Pointer 0
     LLHAAA    DCW  @P@                * Value P
     LMEAAA    DCW  @I9I@              * Pointer 0
     LMGAAA    DCW  @798@              * Pointer 0
     LMHAAA    DCW  @010@              * Pointer 0
     LNGAAA    DCW  @I3A@              * Pointer 0
     LNHAAA    DCW  @I8I@              * Pointer 0
     LOGAAA    DCW  @011@              * Pointer 0
     LOHAAA    DCW  @0000J@            * Value 0000J
     LPEAAA    DCW  @0@                * Value 0
     LPHAAA    DCW  @008@              * Pointer 0
     LRGAAA    DCW  @007@              * Pointer 0
     LSHAAA    DCW  @100000@           * Value 100000
     LTHAAA    DCW  @00042@            * Value 00042
     LUGAAA    DCW  @%@                * Value %
     LUHAAA    DCW  @00019@            * Value 00019
     LVHAAA    DCW  @604@              * Pointer 0
     LWDAAA    DCW  @605@              * Pointer 0
     LXDAAA    DCW  @00001@            * Value 00001
     LXFAAA    DCW  @ @                * Value  
     LYDAAA    DCW  @014@              * Pointer 0
     LYFAAA    DCW  @627@              * Pointer 0
     LZDAAA    DCW  @003@              * Pointer 0
     LZFAAA    DCW  @201@              * Pointer 0
     LZGAAA    DCW  @C@                * Value C

               END  START              * End of program code.
