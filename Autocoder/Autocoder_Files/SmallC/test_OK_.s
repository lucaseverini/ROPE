     ****************************************************************
     ***  test_OK.s
     ***  Generated by Small-C Compiler on 12-Mar-2015 4:27:42 PM
     ****************************************************************
     ****************************************************************

     READ      EQU  001                * Read area
     PUNCH     EQU  101                * Punch area
     PRINT     EQU  201                * Print area
     
     PRCPOS    DCW  000                * char position in print area
     PUCPOS    DCW  000                * char position in punch area
     PUNSIZ    DCW  @080@              * Size of punch area
     PRTSIZ    DCW  @132@              * Size of print area
     EOS       DCW  @'@                * End Of String char
     EOL       DCW  @;@                * End Of Line char

               ORG  87
     X1        DSA  0                  * INDEX REGISTER 1
               ORG  92
     X2        DSA  0                  * INDEX REGISTER 2
               ORG  97
     X3        DSA  0                  * INDEX REGISTER 3
     
     * I need a single digit flag - should I replace this with a DA?
     RF        EQU  340
     
     ****************************************************************
     
     * SET THE START POSITION OF VARIABLES' DATA

               ORG  4001
               DCW  @69105@

               ORG  4006
               DCW  @0@
               DCW  @1@
               DCW  @2@
               DCW  @3@
               DCW  @4@
               DCW  @5@
               DCW  @6@
               DCW  @7@
               DCW  @8@
               DCW  @9@
               DCW  @A@
               DCW  @B@
               DCW  @C@
               DCW  @D@
               DCW  @E@
               DCW  @F@
               DCW  @'@

               ORG  4023
               DCW  @201@

               ORG  4026
               DCW  @200@

               ORG  4033
               DCW  @081@

               ORG  4038
               DCW  @D@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4044
               DCW  @F@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4050
               DCW  @00111@

               ORG  4055
               DCW  @05Y@

               ORG  4058
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @'@

               ORG  4067
               DCW  @07'@

               ORG  4070
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @'@

               ORG  4079
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @'@

               ORG  4088
               DCW  @C@
               DCW  @3@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  4095
               DCW  @C@
               DCW  @3@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4102
               DCW  @C@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  4108
               DCW  @C@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4114
               DCW  @C@
               DCW  @2@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  4121
               DCW  @C@
               DCW  @2@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4128
               DCW  @C@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  4134
               DCW  @C@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4140
               DCW  @C@
               DCW  @2@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  4147
               DCW  @C@
               DCW  @2@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4154
               DCW  @C@
               DCW  @3@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  4161
               DCW  @C@
               DCW  @3@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4168
               DCW  @X@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4174
               DCW  @E@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4180
               DCW  @E@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4186
               DCW  @X@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4192
               DCW  @A@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @ @
               DCW  @B@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4203
               DCW  @A@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @ @
               DCW  @B@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4214
               DCW  @A@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @ @
               DCW  @B@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  4225
               DCW  @;@
               DCW  @D@
               DCW  @O@
               DCW  @N@
               DCW  @E@
               DCW  @.@
               DCW  @;@
               DCW  @'@

     * SET THE START POSITION OF CODE
               ORG  4500
     START     NOP  

     * SET THE STACK POINTER
               SBR  X2,400
               MCW  X2,X3

               B    LPDAAA             * Jump to function main
               H                       * Program executed.

     ********************************************************************************
     * FunctionDefinition(itoa)
     ********************************************************************************
     LXAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3

     ***************************************
     * BeginBlock [Block LYAAAA:null]
               LCA  LRDAAA,9+X3
               LCA  LSDAAA,14+X3
               MA   LTDAAA,X2
     * Assignment (start = str)
     * VariableExpression (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LUDAAA,X2
               LCA  15992+X3,0+X2
     * Push (LVDAAA:3)
               MA   LUDAAA,X2
               LCA  LVDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1
               MA   LWDAAA,X2
     * If [if ((value < 0) then [Block LZAAAA:LYAAAA] else [if ((value == 0) then [Block LABAAA:LYAAAA]]]
     * LessThanExpression (value < 0)
     * VariableExpression (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LXDAAA,X2
               LCA  15997+X3,0+X2
               B    LYDAAA             * Jump to snippet clean_number
     * ConstantExpression (0 : LAEAAA)
     * Push (LAEAAA:5)
               MA   LXDAAA,X2
               LCA  LAEAAA,0+X2
               B    LYDAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
               MCW  LAEAAA,0+X2
               BL   LBEAAA             * Jump if less
               B    LCEAAA             * Jump to End
     LBEAAA    MCW  LSDAAA,0+X2        * Less
     LCEAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LCBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LZAAAA:LYAAAA]
     * Assignment (( *(str++) ) = '-')
     * ConstantExpression ('-' : @-@)
     * Push (@-@:1)
               MA   LFEAAA,X2
               LCA  @-@,0+X2
     * PostIncrement (str++)
     * Push (LGEAAA:3)
               MA   LUDAAA,X2
               LCA  LGEAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
               MA   LFEAAA,0+X1
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1
               MA   LHEAAA,X2
     * Assignment (value = (-value))
     * NegExpression (-value)
     * VariableExpression (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LXDAAA,X2
               LCA  15997+X3,0+X2
               ZS   0+X2
               B    LYDAAA             * Jump to snippet clean_number
     * Push (LWDAAA:3)
               MA   LUDAAA,X2
               LCA  LWDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1
               MA   LDEAAA,X2
     LZAAAA    NOP                     * Return
               BCE  LYAAAA,RF,R        * Jump back to caller
     * EndBlock [Block LZAAAA:LYAAAA]
     ***************************************

               B    LDBAAA             * Jump when true
     LCBAAA    NOP                     * Executed when False
     * If [if ((value == 0) then [Block LABAAA:LYAAAA]]
     * EqualExpression (value == 0)
     * VariableExpression (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LXDAAA,X2
               LCA  15997+X3,0+X2
               B    LYDAAA             * Jump to snippet clean_number
     * ConstantExpression (0 : LAEAAA)
     * Push (LAEAAA:5)
               MA   LXDAAA,X2
               LCA  LAEAAA,0+X2
               B    LYDAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Push (LAEAAA:5)
               MA   LXDAAA,X2
               LCA  LAEAAA,0+X2
               BE   LIEAAA             * Jump if equal
               B    LJEAAA             * Jump to End
     LIEAAA    MCW  LSDAAA,0+X2        * Equal
     LJEAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LBBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LABAAA:LYAAAA]
     * Assignment ((str[0]) = '0')
     * ConstantExpression ('0' : @0@)
     * Push (@0@:1)
               MA   LFEAAA,X2
               LCA  @0@,0+X2
     * VariableExpression (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LUDAAA,X2
               LCA  15992+X3,0+X2
     * ConstantExpression (0 : LAEAAA)
     * Push (LAEAAA:5)
               MA   LXDAAA,X2
               LCA  LAEAAA,0+X2
     * raw index on the stack
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LWDAAA,X2
     * STACK top is location in array now.
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1
               MA   LHEAAA,X2
     * Assignment ((str[1]) = '\0')
     * ConstantExpression ('\0' : EOS)
     * Push (EOS:1)
               MA   LFEAAA,X2
               LCA  EOS,0+X2
     * VariableExpression (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LUDAAA,X2
               LCA  15992+X3,0+X2
     * ConstantExpression (1 : LSDAAA)
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
     * raw index on the stack
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LWDAAA,X2
     * STACK top is location in array now.
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1
               MA   LHEAAA,X2
     * VariableExpression (start : 6+X3)
     * Push (6+X3:3)
               MA   LUDAAA,X2
               LCA  6+X3,0+X2
     * Pop (15984+X3:3)
               LCA  0+X2,15984+X3
               MA   LWDAAA,X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
               B    LABAAA             * Jump back to caller
     LABAAA    NOP                     * Return
               BCE  LYAAAA,RF,R        * Jump back to caller
     * EndBlock [Block LABAAA:LYAAAA]
     ***************************************

     LBBAAA    NOP                     * Executed when False
     LDBAAA    NOP                     * Executed when True
     * While [while ((exp <= (value / base))) (exp = (exp * base)) top:LEBAAA bottom:LFBAAA]
     LEBAAA    NOP                     * Top of the loop
     * LessThanOrEqualExpression (exp <= (value / base))
     * VariableExpression (exp : 14+X3)
     * Push (14+X3:5)
               MA   LXDAAA,X2
               LCA  14+X3,0+X2
               B    LYDAAA             * Jump to snippet clean_number
     * Divide (value / base)
     * VariableExpression (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LXDAAA,X2
               LCA  15989+X3,0+X2
     * VariableExpression (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LXDAAA,X2
               LCA  15997+X3,0+X2
               B    LSEAAA             * Jump to snippet SNIP_DIV
               MCW  0+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
               B    LYDAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
               MCW  LSDAAA,0+X2
               BH   LYEAAA             * Jump if less or equal
               B    LZEAAA             * Jump to End
     LYEAAA    MCW  LAEAAA,0+X2        * Less or equal
     LZEAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LFBAAA,5+X2,       * Jump to bottom
     * Assignment (exp = (exp * base))
     * Multiplication (exp * base)
     * VariableExpression (exp : 14+X3)
     * Push (14+X3:5)
               MA   LXDAAA,X2
               LCA  14+X3,0+X2
     * VariableExpression (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LXDAAA,X2
               LCA  15989+X3,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * Push (LTDAAA:3)
               MA   LUDAAA,X2
               LCA  LTDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1
               MA   LDEAAA,X2
               B    LEBAAA             * Jump to top
     LFBAAA    NOP                     * Bottom of the loop
     * While [while (exp) [Block LGBAAA:LYAAAA] top:LHBAAA bottom:LIBAAA]
     LHBAAA    NOP                     * Top of the loop
     * VariableExpression (exp : 14+X3)
     * Push (14+X3:5)
               MA   LXDAAA,X2
               LCA  14+X3,0+X2
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LIBAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LGBAAA:LYAAAA]
     * Assignment (( *(str++) ) = (digits[(value / exp)]))
     * SubScriptEpression (digits[(value / exp)])
     * VariableExpression (digits : 9+X3)
     * Push (9+X3:3)
               MA   LUDAAA,X2
               LCA  9+X3,0+X2
     * Divide (value / exp)
     * VariableExpression (exp : 14+X3)
     * Push (14+X3:5)
               MA   LXDAAA,X2
               LCA  14+X3,0+X2
     * VariableExpression (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LXDAAA,X2
               LCA  15997+X3,0+X2
               B    LSEAAA             * Jump to snippet SNIP_DIV
               MCW  0+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * raw index on the stack
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LWDAAA,X2
     * STACK top is location in array now.
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:1)
               MA   LFEAAA,X2
               LCA  0+X1,0+X2
     * PostIncrement (str++)
     * Push (LGEAAA:3)
               MA   LUDAAA,X2
               LCA  LGEAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
               MA   LFEAAA,0+X1
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1
               MA   LHEAAA,X2
     * Assignment (value = (value % exp))
     * ModuloExpression (value % exp)
     * VariableExpression (exp : 14+X3)
     * Push (14+X3:5)
               MA   LXDAAA,X2
               LCA  14+X3,0+X2
     * VariableExpression (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LXDAAA,X2
               LCA  15997+X3,0+X2
               B    LSEAAA             * Jump to snippet SNIP_DIV
     * Pop (5)
               MA   LDEAAA,X2
     * Push (LWDAAA:3)
               MA   LUDAAA,X2
               LCA  LWDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1
               MA   LDEAAA,X2
     * Assignment (exp = (exp / base))
     * Divide (exp / base)
     * VariableExpression (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LXDAAA,X2
               LCA  15989+X3,0+X2
     * VariableExpression (exp : 14+X3)
     * Push (14+X3:5)
               MA   LXDAAA,X2
               LCA  14+X3,0+X2
               B    LSEAAA             * Jump to snippet SNIP_DIV
               MCW  0+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * Push (LTDAAA:3)
               MA   LUDAAA,X2
               LCA  LTDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1
               MA   LDEAAA,X2
     LGBAAA    NOP                     * Return
               BCE  LYAAAA,RF,R        * Jump back to caller
     * EndBlock [Block LGBAAA:LYAAAA]
     ***************************************

               B    LHBAAA             * Jump to top
     LIBAAA    NOP                     * Bottom of the loop
     * Assignment (( *str ) = '\0')
     * ConstantExpression ('\0' : EOS)
     * Push (EOS:1)
               MA   LFEAAA,X2
               LCA  EOS,0+X2
     * VariableExpression (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LUDAAA,X2
               LCA  15992+X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1
               MA   LHEAAA,X2
     * VariableExpression (start : 6+X3)
     * Push (6+X3:3)
               MA   LUDAAA,X2
               LCA  6+X3,0+X2
     * Pop (15984+X3:3)
               LCA  0+X2,15984+X3
               MA   LWDAAA,X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
               B    LYAAAA             * Jump back to caller
     LYAAAA    NOP                     * Return
               MA   LAFAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LYAAAA:null]
     ***************************************

               LCA  3+X3,X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * FunctionDefinition(puts)
     ********************************************************************************
     LUBAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3

     ***************************************
     * BeginBlock [Block LVBAAA:null]
               MA   LUDAAA,X2
     * While [while ((( *s ) != '\0')) [Block LWBAAA:LVBAAA] top:LXBAAA bottom:LYBAAA]
     LXBAAA    NOP                     * Top of the loop
     * NotEqualExpression (( *s ) != '\0')
     * DereferenceExpression ( *s )
     * VariableExpression (s : 15997+X3)
     * Push (15997+X3:3)
               MA   LUDAAA,X2
               LCA  15997+X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:1)
               MA   LFEAAA,X2
               LCA  0+X1,0+X2
     * ConstantExpression ('\0' : EOS)
     * Push (EOS:1)
               MA   LFEAAA,X2
               LCA  EOS,0+X2
               C    0+X2,15999+X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               BE   LBFAAA             * Jump if equal
               B    LCFAAA             * Jump to End
     LBFAAA    MCW  LAEAAA,0+X2        * Equal
     LCFAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LYBAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LWBAAA:LVBAAA]
     * FunctionCallExpr putchar(( *(s++) ))
     * Push (5)
               MA   LXDAAA,X2
     * DereferenceExpression ( *(s++) )
     * PostIncrement (s++)
     * Push (LWDAAA:3)
               MA   LUDAAA,X2
               LCA  LWDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
               MA   LFEAAA,0+X1
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:1)
               MA   LFEAAA,X2
               LCA  0+X1,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LJBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     LWBAAA    NOP                     * Return
               BCE  LVBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LWBAAA:LVBAAA]
     ***************************************

               B    LXBAAA             * Jump to top
     LYBAAA    NOP                     * Bottom of the loop
     LVBAAA    NOP                     * Return
               MA   LWDAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LVBAAA:null]
     ***************************************

               LCA  3+X3,X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * FunctionDefinition(genRand)
     ********************************************************************************
     LBAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3

     ***************************************
     * BeginBlock [Block LCAAAA:null]
               MA   LUDAAA,X2
     * Assignment (seed = (((42 * seed) + 19) % 100000))
     * ModuloExpression (((42 * seed) + 19) % 100000)
     * ConstantExpression (100000 : LDFAAA)
     * Push (LDFAAA:5)
               MA   LXDAAA,X2
               LCA  LDFAAA,0+X2
     * Addition ((42 * seed) + 19)
     * Multiplication (42 * seed)
     * ConstantExpression (42 : LEFAAA)
     * Push (LEFAAA:5)
               MA   LXDAAA,X2
               LCA  LEFAAA,0+X2
     * StaticVariableExpression (seed : 4005)
     * Push (4005:5)
               MA   LXDAAA,X2
               LCA  4005,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * ConstantExpression (19 : LFFAAA)
     * Push (LFFAAA:5)
               MA   LXDAAA,X2
               LCA  LFFAAA,0+X2
               A    0+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
               B    LSEAAA             * Jump to snippet SNIP_DIV
     * Pop (5)
               MA   LDEAAA,X2
     * Push (LGFAAA:3)
               MA   LUDAAA,X2
               LCA  LGFAAA,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1
               MA   LDEAAA,X2
     * StaticVariableExpression (seed : 4005)
     * Push (4005:5)
               MA   LXDAAA,X2
               LCA  4005,0+X2
     * Pop (15997+X3:5)
               LCA  0+X2,15997+X3
               MA   LDEAAA,X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
               B    LCAAAA             * Jump back to caller
     LCAAAA    NOP                     * Return
               MA   LWDAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LCAAAA:null]
     ***************************************

               LCA  3+X3,X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * FunctionDefinition(main)
     ********************************************************************************
     LPDAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3

     ***************************************
     * BeginBlock [Block LQDAAA:null]
               LCA  LHFAAA,6+X3
               LCA  LSDAAA,11+X3
               LCA  LSDAAA,16+X3
               LCA  LIFAAA,21+X3
               MA   LJFAAA,X2
     * FunctionCallExpr printf(STR_LIT_10, c3)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (c3 : 6+X3)
     * Push (6+X3:3)
               MA   LUDAAA,X2
               LCA  6+X3,0+X2
     * ArrayNameExpresssion(STR_LIT_10:char [7])
     * Push (LKFAAA:3)
               MA   LUDAAA,X2
               LCA  LKFAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_11, ((int) c3))
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (c3 : 6+X3)
     * Push (6+X3:3)
               MA   LUDAAA,X2
               LCA  6+X3,0+X2
               B    LLFAAA             * Jump to snippet pointer_to_number
     * ArrayNameExpresssion(STR_LIT_11:char [7])
     * Push (LUFAAA:3)
               MA   LUDAAA,X2
               LCA  LUFAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_12, c)
     * Push (5)
               MA   LXDAAA,X2
     * StaticVariableExpression (c : 4057)
     * Push (4057:3)
               MA   LUDAAA,X2
               LCA  4057,0+X2
     * ArrayNameExpresssion(STR_LIT_12:char [6])
     * Push (LVFAAA:3)
               MA   LUDAAA,X2
               LCA  LVFAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_13, ((int) c))
     * Push (5)
               MA   LXDAAA,X2
     * StaticVariableExpression (c : 4057)
     * Push (4057:3)
               MA   LUDAAA,X2
               LCA  4057,0+X2
               B    LLFAAA             * Jump to snippet pointer_to_number
     * ArrayNameExpresssion(STR_LIT_13:char [6])
     * Push (LWFAAA:3)
               MA   LUDAAA,X2
               LCA  LWFAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_14, c2)
     * Push (5)
               MA   LXDAAA,X2
     * StaticVariableExpression (c2 : 4069)
     * Push (4069:3)
               MA   LUDAAA,X2
               LCA  4069,0+X2
     * ArrayNameExpresssion(STR_LIT_14:char [7])
     * Push (LXFAAA:3)
               MA   LUDAAA,X2
               LCA  LXFAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_15, ((int) c2))
     * Push (5)
               MA   LXDAAA,X2
     * StaticVariableExpression (c2 : 4069)
     * Push (4069:3)
               MA   LUDAAA,X2
               LCA  4069,0+X2
               B    LLFAAA             * Jump to snippet pointer_to_number
     * ArrayNameExpresssion(STR_LIT_15:char [7])
     * Push (LYFAAA:3)
               MA   LUDAAA,X2
               LCA  LYFAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Assignment ((c[3]) = 'B')
     * ConstantExpression ('B' : @B@)
     * Push (@B@:1)
               MA   LFEAAA,X2
               LCA  @B@,0+X2
     * StaticVariableExpression (c : 4057)
     * Push (4057:3)
               MA   LUDAAA,X2
               LCA  4057,0+X2
     * ConstantExpression (3 : LAGAAA)
     * Push (LAGAAA:5)
               MA   LXDAAA,X2
               LCA  LAGAAA,0+X2
     * raw index on the stack
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LWDAAA,X2
     * STACK top is location in array now.
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1
               MA   LHEAAA,X2
     * FunctionCallExpr printf(STR_LIT_16, c)
     * Push (5)
               MA   LXDAAA,X2
     * StaticVariableExpression (c : 4057)
     * Push (4057:3)
               MA   LUDAAA,X2
               LCA  4057,0+X2
     * ArrayNameExpresssion(STR_LIT_16:char [6])
     * Push (LBGAAA:3)
               MA   LUDAAA,X2
               LCA  LBGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_17, ((int) c))
     * Push (5)
               MA   LXDAAA,X2
     * StaticVariableExpression (c : 4057)
     * Push (4057:3)
               MA   LUDAAA,X2
               LCA  4057,0+X2
               B    LLFAAA             * Jump to snippet pointer_to_number
     * ArrayNameExpresssion(STR_LIT_17:char [6])
     * Push (LCGAAA:3)
               MA   LUDAAA,X2
               LCA  LCGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_18, c2)
     * Push (5)
               MA   LXDAAA,X2
     * StaticVariableExpression (c2 : 4069)
     * Push (4069:3)
               MA   LUDAAA,X2
               LCA  4069,0+X2
     * ArrayNameExpresssion(STR_LIT_18:char [7])
     * Push (LDGAAA:3)
               MA   LUDAAA,X2
               LCA  LDGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_19, ((int) c2))
     * Push (5)
               MA   LXDAAA,X2
     * StaticVariableExpression (c2 : 4069)
     * Push (4069:3)
               MA   LUDAAA,X2
               LCA  4069,0+X2
               B    LLFAAA             * Jump to snippet pointer_to_number
     * ArrayNameExpresssion(STR_LIT_19:char [7])
     * Push (LEGAAA:3)
               MA   LUDAAA,X2
               LCA  LEGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_20, c3)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (c3 : 6+X3)
     * Push (6+X3:3)
               MA   LUDAAA,X2
               LCA  6+X3,0+X2
     * ArrayNameExpresssion(STR_LIT_20:char [7])
     * Push (LFGAAA:3)
               MA   LUDAAA,X2
               LCA  LFGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_21, ((int) c3))
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (c3 : 6+X3)
     * Push (6+X3:3)
               MA   LUDAAA,X2
               LCA  6+X3,0+X2
               B    LLFAAA             * Jump to snippet pointer_to_number
     * ArrayNameExpresssion(STR_LIT_21:char [7])
     * Push (LGGAAA:3)
               MA   LUDAAA,X2
               LCA  LGGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_22, x)
     * Push (5)
               MA   LXDAAA,X2
     * StaticVariableExpression (x : 4054)
     * Push (4054:5)
               MA   LXDAAA,X2
               LCA  4054,0+X2
     * ArrayNameExpresssion(STR_LIT_22:char [6])
     * Push (LHGAAA:3)
               MA   LUDAAA,X2
               LCA  LHGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_23, e)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (e : 21+X3)
     * Push (21+X3:5)
               MA   LXDAAA,X2
               LCA  21+X3,0+X2
     * ArrayNameExpresssion(STR_LIT_23:char [6])
     * Push (LIGAAA:3)
               MA   LUDAAA,X2
               LCA  LIGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Assignment (x = 222)
     * ConstantExpression (222 : LJGAAA)
     * Push (LJGAAA:5)
               MA   LXDAAA,X2
               LCA  LJGAAA,0+X2
     * Push (LKGAAA:3)
               MA   LUDAAA,X2
               LCA  LKGAAA,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_24, e)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (e : 21+X3)
     * Push (21+X3:5)
               MA   LXDAAA,X2
               LCA  21+X3,0+X2
     * ArrayNameExpresssion(STR_LIT_24:char [6])
     * Push (LLGAAA:3)
               MA   LUDAAA,X2
               LCA  LLGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_25, x)
     * Push (5)
               MA   LXDAAA,X2
     * StaticVariableExpression (x : 4054)
     * Push (4054:5)
               MA   LXDAAA,X2
               LCA  4054,0+X2
     * ArrayNameExpresssion(STR_LIT_25:char [6])
     * Push (LMGAAA:3)
               MA   LUDAAA,X2
               LCA  LMGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_26, a, b)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (b : 16+X3)
     * Push (16+X3:5)
               MA   LXDAAA,X2
               LCA  16+X3,0+X2
     * VariableExpression (a : 11+X3)
     * Push (11+X3:5)
               MA   LXDAAA,X2
               LCA  11+X3,0+X2
     * ArrayNameExpresssion(STR_LIT_26:char [11])
     * Push (LNGAAA:3)
               MA   LUDAAA,X2
               LCA  LNGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Assignment (a = 2)
     * ConstantExpression (2 : LOGAAA)
     * Push (LOGAAA:5)
               MA   LXDAAA,X2
               LCA  LOGAAA,0+X2
     * Push (LPGAAA:3)
               MA   LUDAAA,X2
               LCA  LPGAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_27, a, b)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (b : 16+X3)
     * Push (16+X3:5)
               MA   LXDAAA,X2
               LCA  16+X3,0+X2
     * VariableExpression (a : 11+X3)
     * Push (11+X3:5)
               MA   LXDAAA,X2
               LCA  11+X3,0+X2
     * ArrayNameExpresssion(STR_LIT_27:char [11])
     * Push (LQGAAA:3)
               MA   LUDAAA,X2
               LCA  LQGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Assignment (b = 3)
     * ConstantExpression (3 : LAGAAA)
     * Push (LAGAAA:5)
               MA   LXDAAA,X2
               LCA  LAGAAA,0+X2
     * Push (LRGAAA:3)
               MA   LUDAAA,X2
               LCA  LRGAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_28, a, b)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (b : 16+X3)
     * Push (16+X3:5)
               MA   LXDAAA,X2
               LCA  16+X3,0+X2
     * VariableExpression (a : 11+X3)
     * Push (11+X3:5)
               MA   LXDAAA,X2
               LCA  11+X3,0+X2
     * ArrayNameExpresssion(STR_LIT_28:char [11])
     * Push (LSGAAA:3)
               MA   LUDAAA,X2
               LCA  LSGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr func(a, b)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (b : 16+X3)
     * Push (16+X3:5)
               MA   LXDAAA,X2
               LCA  16+X3,0+X2
     * VariableExpression (a : 11+X3)
     * Push (11+X3:5)
               MA   LXDAAA,X2
               LCA  11+X3,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNDAAA             * Jump to function func
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_29)
     * Push (5)
               MA   LXDAAA,X2
     * ArrayNameExpresssion(STR_LIT_29:char [8])
     * Push (LTGAAA:3)
               MA   LUDAAA,X2
               LCA  LTGAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     LQDAAA    NOP                     * Return
               MA   LUGAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LQDAAA:null]
     ***************************************

               LCA  3+X3,X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * FunctionDefinition(strcpy)
     ********************************************************************************
     LJAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3

     ***************************************
     * BeginBlock [Block LKAAAA:null]
               MA   LUDAAA,X2
     * While [while (((( *(dest++) ) = ( *(src++) )) != '\0')) [] top:LLAAAA bottom:LMAAAA]
     LLAAAA    NOP                     * Top of the loop
     * NotEqualExpression ((( *(dest++) ) = ( *(src++) )) != '\0')
     * Assignment (( *(dest++) ) = ( *(src++) ))
     * DereferenceExpression ( *(src++) )
     * PostIncrement (src++)
     * Push (LXGAAA:3)
               MA   LUDAAA,X2
               LCA  LXGAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
               MA   LFEAAA,0+X1
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:1)
               MA   LFEAAA,X2
               LCA  0+X1,0+X2
     * PostIncrement (dest++)
     * Push (LWDAAA:3)
               MA   LUDAAA,X2
               LCA  LWDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
               MA   LFEAAA,0+X1
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
               LCA  0+X2,0+X1
     * ConstantExpression ('\0' : EOS)
     * Push (EOS:1)
               MA   LFEAAA,X2
               LCA  EOS,0+X2
               C    0+X2,15999+X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               BE   LVGAAA             * Jump if equal
               B    LWGAAA             * Jump to End
     LVGAAA    MCW  LAEAAA,0+X2        * Equal
     LWGAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LMAAAA,5+X2,       * Jump to bottom
               B    LLAAAA             * Jump to top
     LMAAAA    NOP                     * Bottom of the loop
     LKAAAA    NOP                     * Return
               MA   LWDAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LKAAAA:null]
     ***************************************

               LCA  3+X3,X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * FunctionDefinition(strlen)
     ********************************************************************************
     LFAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3

     ***************************************
     * BeginBlock [Block LGAAAA:null]
               LCA  LYGAAA,8+X3
               MA   LZGAAA,X2
     * While [while (((str[(++len)]) != '\0')) [] top:LHAAAA bottom:LIAAAA]
     LHAAAA    NOP                     * Top of the loop
     * NotEqualExpression ((str[(++len)]) != '\0')
     * SubScriptEpression (str[(++len)])
     * VariableExpression (str : 15997+X3)
     * Push (15997+X3:3)
               MA   LUDAAA,X2
               LCA  15997+X3,0+X2
     * PreIncrement((++len)
     * Push (LZGAAA:3)
               MA   LUDAAA,X2
               LCA  LZGAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
               A    LSDAAA,0+X1
     * Push (0+X1:5)
               MA   LXDAAA,X2
               LCA  0+X1,0+X2
     * raw index on the stack
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LWDAAA,X2
     * STACK top is location in array now.
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:1)
               MA   LFEAAA,X2
               LCA  0+X1,0+X2
     * ConstantExpression ('\0' : EOS)
     * Push (EOS:1)
               MA   LFEAAA,X2
               LCA  EOS,0+X2
               C    0+X2,15999+X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               BE   LAHAAA             * Jump if equal
               B    LBHAAA             * Jump to End
     LAHAAA    MCW  LAEAAA,0+X2        * Equal
     LBHAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LIAAAA,5+X2,       * Jump to bottom
               B    LHAAAA             * Jump to top
     LIAAAA    NOP                     * Bottom of the loop
     * VariableExpression (len : 8+X3)
     * Push (8+X3:5)
               MA   LXDAAA,X2
               LCA  8+X3,0+X2
     * Pop (15994+X3:5)
               LCA  0+X2,15994+X3
               MA   LDEAAA,X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
               B    LGAAAA             * Jump back to caller
     LGAAAA    NOP                     * Return
               MA   LGEAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LGAAAA:null]
     ***************************************

               LCA  3+X3,X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * FunctionDefinition(func)
     ********************************************************************************
     LNDAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3

     ***************************************
     * BeginBlock [Block LODAAA:null]
               LCA  LIFAAA,13+X3
               MA   LCHAAA,X2
     * Assignment (d = (a2 + b2))
     * Addition (a2 + b2)
     * VariableExpression (a2 : 15997+X3)
     * Push (15997+X3:5)
               MA   LXDAAA,X2
               LCA  15997+X3,0+X2
     * VariableExpression (b2 : 15992+X3)
     * Push (15992+X3:5)
               MA   LXDAAA,X2
               LCA  15992+X3,0+X2
               A    0+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
     * Push (LZGAAA:3)
               MA   LUDAAA,X2
               LCA  LZGAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_5, d)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (d : 8+X3)
     * Push (8+X3:5)
               MA   LXDAAA,X2
               LCA  8+X3,0+X2
     * ArrayNameExpresssion(STR_LIT_5:char [6])
     * Push (LDHAAA:3)
               MA   LUDAAA,X2
               LCA  LDHAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * FunctionCallExpr printf(STR_LIT_6, f)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (f : 13+X3)
     * Push (13+X3:5)
               MA   LXDAAA,X2
               LCA  13+X3,0+X2
     * ArrayNameExpresssion(STR_LIT_6:char [6])
     * Push (LEHAAA:3)
               MA   LUDAAA,X2
               LCA  LEHAAA,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * ConstantExpression (0 : LAEAAA)
     * Push (LAEAAA:5)
               MA   LXDAAA,X2
               LCA  LAEAAA,0+X2
     * Pop (15987+X3:5)
               LCA  0+X2,15987+X3
               MA   LDEAAA,X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
               B    LODAAA             * Jump back to caller
     LODAAA    NOP                     * Return
               MA   LFHAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LODAAA:null]
     ***************************************

               LCA  3+X3,X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * FunctionDefinition(printf)
     ********************************************************************************
     LNCAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3

     ***************************************
     * BeginBlock [Block LOCAAA:null]
               MA   LGHAAA,X2
     * Assignment (arg = ((*char) (( &cformat_str ) + 15997)))
     * Addition (( &cformat_str ) + 15997)
     * AddressOfExpression ( &cformat_str )
     * Push (LWDAAA:3)
               MA   LUDAAA,X2
               LCA  LWDAAA,0+X2
               MA   X3,0+X2
     * ConstantExpression (15997 : LWDAAA)
     * Push (LWDAAA:3)
               MA   LUDAAA,X2
               LCA  LWDAAA,0+X2
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LWDAAA,X2
     * Push (LVDAAA:3)
               MA   LUDAAA,X2
               LCA  LVDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1
               MA   LWDAAA,X2
     * While [while (((c = ( *(cformat_str++) )) != '\0')) [Block LPCAAA:LOCAAA] top:LHDAAA bottom:LIDAAA]
     LHDAAA    NOP                     * Top of the loop
     * NotEqualExpression ((c = ( *(cformat_str++) )) != '\0')
     * Assignment (c = ( *(cformat_str++) ))
     * DereferenceExpression ( *(cformat_str++) )
     * PostIncrement (cformat_str++)
     * Push (LWDAAA:3)
               MA   LUDAAA,X2
               LCA  LWDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
               MA   LFEAAA,0+X1
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:1)
               MA   LFEAAA,X2
               LCA  0+X1,0+X2
     * Push (LGHAAA:3)
               MA   LUDAAA,X2
               LCA  LGHAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
               LCA  0+X2,0+X1
     * ConstantExpression ('\0' : EOS)
     * Push (EOS:1)
               MA   LFEAAA,X2
               LCA  EOS,0+X2
               C    0+X2,15999+X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               BE   LHHAAA             * Jump if equal
               B    LIHAAA             * Jump to End
     LHHAAA    MCW  LAEAAA,0+X2        * Equal
     LIHAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LIDAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LPCAAA:LOCAAA]
     * If [if ((c != '%') then [Block LQCAAA:LPCAAA] else [Block LRCAAA:LPCAAA]]
     * NotEqualExpression (c != '%')
     * VariableExpression (c : 7+X3)
     * Push (7+X3:1)
               MA   LFEAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression ('%' : @%@)
     * Push (@%@:1)
               MA   LFEAAA,X2
               LCA  @%@,0+X2
               C    0+X2,15999+X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               BE   LJHAAA             * Jump if equal
               B    LKHAAA             * Jump to End
     LJHAAA    MCW  LAEAAA,0+X2        * Equal
     LKHAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LFDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LQCAAA:LPCAAA]
     * FunctionCallExpr putchar(c)
     * Push (5)
               MA   LXDAAA,X2
     * VariableExpression (c : 7+X3)
     * Push (7+X3:1)
               MA   LFEAAA,X2
               LCA  7+X3,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LJBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     LQCAAA    NOP                     * Return
               BCE  LPCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LQCAAA:LPCAAA]
     ***************************************

               B    LGDAAA             * Jump when true
     LFDAAA    NOP                     * Executed when False

     ***************************************
     * BeginBlock [Block LRCAAA:LPCAAA]
     * Assignment (c = ( *(cformat_str++) ))
     * DereferenceExpression ( *(cformat_str++) )
     * PostIncrement (cformat_str++)
     * Push (LWDAAA:3)
               MA   LUDAAA,X2
               LCA  LWDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
               MA   LFEAAA,0+X1
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:1)
               MA   LFEAAA,X2
               LCA  0+X1,0+X2
     * Push (LGHAAA:3)
               MA   LUDAAA,X2
               LCA  LGHAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1
               MA   LHEAAA,X2
     * If [if ((c == '%') then [Block LSCAAA:LRCAAA] else [if ((c == 'C') then [Block LTCAAA:LRCAAA] else [if ((c == 'S') then [Block LUCAAA:LRCAAA] else [if ((c == 'D') then [Block LVCAAA:LRCAAA] else [Block LWCAAA:LRCAAA]]]]]
     * EqualExpression (c == '%')
     * VariableExpression (c : 7+X3)
     * Push (7+X3:1)
               MA   LFEAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression ('%' : @%@)
     * Push (@%@:1)
               MA   LFEAAA,X2
               LCA  @%@,0+X2
               C    0+X2,15999+X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Push (LAEAAA:5)
               MA   LXDAAA,X2
               LCA  LAEAAA,0+X2
               BE   LMHAAA             * Jump if equal
               B    LNHAAA             * Jump to End
     LMHAAA    MCW  LSDAAA,0+X2        * Equal
     LNHAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LDDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LSCAAA:LRCAAA]
     * FunctionCallExpr putchar('%')
     * Push (5)
               MA   LXDAAA,X2
     * ConstantExpression ('%' : @%@)
     * Push (@%@:1)
               MA   LFEAAA,X2
               LCA  @%@,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LJBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     LSCAAA    NOP                     * Return
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LSCAAA:LRCAAA]
     ***************************************

               B    LEDAAA             * Jump when true
     LDDAAA    NOP                     * Executed when False
     * If [if ((c == 'C') then [Block LTCAAA:LRCAAA] else [if ((c == 'S') then [Block LUCAAA:LRCAAA] else [if ((c == 'D') then [Block LVCAAA:LRCAAA] else [Block LWCAAA:LRCAAA]]]]
     * EqualExpression (c == 'C')
     * VariableExpression (c : 7+X3)
     * Push (7+X3:1)
               MA   LFEAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression ('C' : @C@)
     * Push (@C@:1)
               MA   LFEAAA,X2
               LCA  @C@,0+X2
               C    0+X2,15999+X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Push (LAEAAA:5)
               MA   LXDAAA,X2
               LCA  LAEAAA,0+X2
               BE   LOHAAA             * Jump if equal
               B    LPHAAA             * Jump to End
     LOHAAA    MCW  LSDAAA,0+X2        * Equal
     LPHAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LBDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LTCAAA:LRCAAA]
     * FunctionCallExpr putchar(( *(arg--) ))
     * Push (5)
               MA   LXDAAA,X2
     * DereferenceExpression ( *(arg--) )
     * PostDecrement (arg--)
     * Push (LVDAAA:3)
               MA   LUDAAA,X2
               LCA  LVDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
               MA   LHEAAA,0+X1
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:1)
               MA   LFEAAA,X2
               LCA  0+X1,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LJBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     LTCAAA    NOP                     * Return
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LTCAAA:LRCAAA]
     ***************************************

               B    LCDAAA             * Jump when true
     LBDAAA    NOP                     * Executed when False
     * If [if ((c == 'S') then [Block LUCAAA:LRCAAA] else [if ((c == 'D') then [Block LVCAAA:LRCAAA] else [Block LWCAAA:LRCAAA]]]
     * EqualExpression (c == 'S')
     * VariableExpression (c : 7+X3)
     * Push (7+X3:1)
               MA   LFEAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression ('S' : @S@)
     * Push (@S@:1)
               MA   LFEAAA,X2
               LCA  @S@,0+X2
               C    0+X2,15999+X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Push (LAEAAA:5)
               MA   LXDAAA,X2
               LCA  LAEAAA,0+X2
               BE   LRHAAA             * Jump if equal
               B    LSHAAA             * Jump to End
     LRHAAA    MCW  LSDAAA,0+X2        * Equal
     LSHAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LZCAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LUCAAA:LRCAAA]
     * FunctionCallExpr puts(( *((**char) arg) ))
     * Push (5)
               MA   LXDAAA,X2
     * DereferenceExpression ( *((**char) arg) )
     * VariableExpression (arg : 6+X3)
     * Push (6+X3:3)
               MA   LUDAAA,X2
               LCA  6+X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LUBAAA             * Jump to function puts
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Assignment (arg = (arg + 15997))
     * Addition (arg + 15997)
     * VariableExpression (arg : 6+X3)
     * Push (6+X3:3)
               MA   LUDAAA,X2
               LCA  6+X3,0+X2
     * ConstantExpression (15997 : LWDAAA)
     * Push (LWDAAA:3)
               MA   LUDAAA,X2
               LCA  LWDAAA,0+X2
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LWDAAA,X2
     * Push (LVDAAA:3)
               MA   LUDAAA,X2
               LCA  LVDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1
               MA   LWDAAA,X2
     LUCAAA    NOP                     * Return
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LUCAAA:LRCAAA]
     ***************************************

               B    LADAAA             * Jump when true
     LZCAAA    NOP                     * Executed when False
     * If [if ((c == 'D') then [Block LVCAAA:LRCAAA] else [Block LWCAAA:LRCAAA]]
     * EqualExpression (c == 'D')
     * VariableExpression (c : 7+X3)
     * Push (7+X3:1)
               MA   LFEAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression ('D' : @D@)
     * Push (@D@:1)
               MA   LFEAAA,X2
               LCA  @D@,0+X2
               C    0+X2,15999+X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Push (LAEAAA:5)
               MA   LXDAAA,X2
               LCA  LAEAAA,0+X2
               BE   LUHAAA             * Jump if equal
               B    LVHAAA             * Jump to End
     LUHAAA    MCW  LSDAAA,0+X2        * Equal
     LVHAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LXCAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LVCAAA:LRCAAA]
               MA   LGHAAA,X2
     * FunctionCallExpr itoa(( *((*int) arg) ), a, 10)
     * Push (3)
               MA   LUDAAA,X2
     * ConstantExpression (10 : LXHAAA)
     * Push (LXHAAA:5)
               MA   LXDAAA,X2
               LCA  LXHAAA,0+X2
     * ArrayNameExpresssion(a:char [7])
     * Push (LZGAAA:3)
               MA   LUDAAA,X2
               LCA  LZGAAA,0+X2
               MA   X3,0+X2
     * DereferenceExpression ( *((*int) arg) )
     * VariableExpression (arg : 6+X3)
     * Push (6+X3:3)
               MA   LUDAAA,X2
               LCA  6+X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:5)
               MA   LXDAAA,X2
               LCA  0+X1,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LXAAAA             * Jump to function itoa
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * FunctionCallExpr puts(a)
     * Push (5)
               MA   LXDAAA,X2
     * ArrayNameExpresssion(a:char [7])
     * Push (LZGAAA:3)
               MA   LUDAAA,X2
               LCA  LZGAAA,0+X2
               MA   X3,0+X2
     * Push (X3:3)
               MA   LUDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LUBAAA             * Jump to function puts
     * Pop (X3:3)
               LCA  0+X2,X3
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (5)
               MA   LDEAAA,X2
     * Assignment (arg = (arg + 15995))
     * Addition (arg + 15995)
     * VariableExpression (arg : 6+X3)
     * Push (6+X3:3)
               MA   LUDAAA,X2
               LCA  6+X3,0+X2
     * ConstantExpression (15995 : LDEAAA)
     * Push (LDEAAA:3)
               MA   LUDAAA,X2
               LCA  LDEAAA,0+X2
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LWDAAA,X2
     * Push (LVDAAA:3)
               MA   LUDAAA,X2
               LCA  LVDAAA,0+X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1
               MA   LWDAAA,X2
     LVCAAA    NOP                     * Return
               MA   LYHAAA,X2
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LVCAAA:LRCAAA]
     ***************************************

               B    LYCAAA             * Jump when true
     LXCAAA    NOP                     * Executed when False

     ***************************************
     * BeginBlock [Block LWCAAA:LRCAAA]
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
               B    LWCAAA             * Jump back to caller
     LWCAAA    NOP                     * Return
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LWCAAA:LRCAAA]
     ***************************************

     LYCAAA    NOP                     * Executed when True
     LADAAA    NOP                     * Executed when True
     LCDAAA    NOP                     * Executed when True
     LEDAAA    NOP                     * Executed when True
     LRCAAA    NOP                     * Return
               BCE  LPCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LRCAAA:LPCAAA]
     ***************************************

     LGDAAA    NOP                     * Executed when True
     LPCAAA    NOP                     * Return
               BCE  LOCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LPCAAA:LOCAAA]
     ***************************************

               B    LHDAAA             * Jump to top
     LIDAAA    NOP                     * Bottom of the loop
     LOCAAA    NOP                     * Return
               MA   LYHAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LOCAAA:null]
     ***************************************

               LCA  3+X3,X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * FunctionDefinition(putchar)
     ********************************************************************************
     LJBAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3

     ***************************************
     * BeginBlock [Block LKBAAA:null]
               MA   LUDAAA,X2
     * If [if ((c != '\n') then [Block LLBAAA:LKBAAA] else [Block LMBAAA:LKBAAA]]
     * NotEqualExpression (c != '\n')
     * VariableExpression (c : 15997+X3)
     * Push (15997+X3:1)
               MA   LFEAAA,X2
               LCA  15997+X3,0+X2
     * ConstantExpression ('\n' : EOL)
     * Push (EOL:1)
               MA   LFEAAA,X2
               LCA  EOL,0+X2
               C    0+X2,15999+X2
     * Pop (1)
               MA   LHEAAA,X2
     * Pop (1)
               MA   LHEAAA,X2
     * Push (LSDAAA:5)
               MA   LXDAAA,X2
               LCA  LSDAAA,0+X2
               BE   LZHAAA             * Jump if equal
               B    LAIAAA             * Jump to End
     LZHAAA    MCW  LAEAAA,0+X2        * Equal
     LAIAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LQBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LLBAAA:LKBAAA]
     * Assignment (( *(__putchar_pos++) ) = c)
     * VariableExpression (c : 15997+X3)
     * Push (15997+X3:1)
               MA   LFEAAA,X2
               LCA  15997+X3,0+X2
     * PostIncrement (__putchar_pos++)
     * Push (LBIAAA:3)
               MA   LUDAAA,X2
               LCA  LBIAAA,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
               MA   LFEAAA,0+X1
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1
               MA   LHEAAA,X2
     LLBAAA    NOP                     * Return
               BCE  LKBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LLBAAA:LKBAAA]
     ***************************************

               B    LRBAAA             * Jump when true
     LQBAAA    NOP                     * Executed when False

     ***************************************
     * BeginBlock [Block LMBAAA:LKBAAA]
     * While [while ((((int) __putchar_last) >= ((int) __putchar_pos))) [Block LNBAAA:LMBAAA] top:LOBAAA bottom:LPBAAA]
     LOBAAA    NOP                     * Top of the loop
     * GreaterThanOrEqualExpression((((int) __putchar_last) >= ((int) __putchar_pos))
     * StaticVariableExpression (__putchar_last : 4028)
     * Push (4028:3)
               MA   LUDAAA,X2
               LCA  4028,0+X2
               B    LLFAAA             * Jump to snippet pointer_to_number
               B    LYDAAA             * Jump to snippet clean_number
     * StaticVariableExpression (__putchar_pos : 4025)
     * Push (4025:3)
               MA   LUDAAA,X2
               LCA  4025,0+X2
               B    LLFAAA             * Jump to snippet pointer_to_number
               B    LYDAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2
     * Pop (5)
               MA   LDEAAA,X2
               MCW  LSDAAA,0+X2
               BL   LCIAAA             * Jump if greater or equal
               B    LDIAAA             * Jump to End
     LCIAAA    MCW  LAEAAA,0+X2        * GreaterOrEqual
     LDIAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LPBAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LNBAAA:LMBAAA]
     * Assignment (( *(__putchar_last--) ) = ' ')
     * ConstantExpression (' ' : @ @)
     * Push (@ @:1)
               MA   LFEAAA,X2
               LCA  @ @,0+X2
     * PostDecrement (__putchar_last--)
     * Push (LFIAAA:3)
               MA   LUDAAA,X2
               LCA  LFIAAA,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Push (0+X1:3)
               MA   LUDAAA,X2
               LCA  0+X1,0+X2
               MA   LHEAAA,0+X1
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1
               MA   LHEAAA,X2
     LNBAAA    NOP                     * Return
               BCE  LMBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LNBAAA:LMBAAA]
     ***************************************

               B    LOBAAA             * Jump to top
     LPBAAA    NOP                     * Bottom of the loop
     * Assignment (__putchar_last = __putchar_pos)
     * StaticVariableExpression (__putchar_pos : 4025)
     * Push (4025:3)
               MA   LUDAAA,X2
               LCA  4025,0+X2
     * Push (LFIAAA:3)
               MA   LUDAAA,X2
               LCA  LFIAAA,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1
               MA   LWDAAA,X2
     * Assignment (__putchar_pos = 201)
     * ConstantExpression (201 : LGIAAA)
     * Push (LGIAAA:3)
               MA   LUDAAA,X2
               LCA  LGIAAA,0+X2
     * Push (LBIAAA:3)
               MA   LUDAAA,X2
               LCA  LBIAAA,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1
               MA   LWDAAA,X2
     * Start asm block
               W    
     * End asm block
     LMBAAA    NOP                     * Return
               BCE  LKBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LMBAAA:LKBAAA]
     ***************************************

     LRBAAA    NOP                     * Executed when True
     * If [if ((__putchar_pos == 333) then [Block LSBAAA:LKBAAA]]
     * EqualExpression (__putchar_pos == 333)
     * StaticVariableExpression (__putchar_pos : 4025)
     * Push (4025:3)
               MA   LUDAAA,X2
               LCA  4025,0+X2
     * ConstantExpression (333 : LJIAAA)
     * Push (LJIAAA:3)
               MA   LUDAAA,X2
               LCA  LJIAAA,0+X2
               C    0+X2,15997+X2
     * Pop (3)
               MA   LWDAAA,X2
     * Pop (3)
               MA   LWDAAA,X2
     * Push (LAEAAA:5)
               MA   LXDAAA,X2
               LCA  LAEAAA,0+X2
               BE   LHIAAA             * Jump if equal
               B    LIIAAA             * Jump to End
     LHIAAA    MCW  LSDAAA,0+X2        * Equal
     LIIAAA    NOP                     * End
               MCS  0+X2,0+X2
     * Pop (5)
               MA   LDEAAA,X2
               BCE  LTBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LSBAAA:LKBAAA]
     * Assignment (__putchar_last = __putchar_pos)
     * StaticVariableExpression (__putchar_pos : 4025)
     * Push (4025:3)
               MA   LUDAAA,X2
               LCA  4025,0+X2
     * Push (LFIAAA:3)
               MA   LUDAAA,X2
               LCA  LFIAAA,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1
               MA   LWDAAA,X2
     * Assignment (__putchar_pos = 201)
     * ConstantExpression (201 : LGIAAA)
     * Push (LGIAAA:3)
               MA   LUDAAA,X2
               LCA  LGIAAA,0+X2
     * Push (LBIAAA:3)
               MA   LUDAAA,X2
               LCA  LBIAAA,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1
               MA   LWDAAA,X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1
               MA   LWDAAA,X2
     * Start asm block
               W    
     * End asm block
     LSBAAA    NOP                     * Return
               BCE  LKBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LSBAAA:LKBAAA]
     ***************************************

     LTBAAA    NOP                     * Executed when False
     LKBAAA    NOP                     * Return
               MA   LWDAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LKBAAA:null]
     ***************************************

               LCA  3+X3,X1
               B    0+X1               * Jump back to caller
     LYDAAA    SBR  X1
     * Normalizes the zone bits of a number, leaving either A=0B=0
     * for a positive or A=0B=1 for a negative
     * Do nothing on either no zone bits or only a b zone bit
               BWZ  LZDAAA,0+X2,2
               BWZ  LZDAAA,0+X2,K
     * else clear the zone bits, as it is positive
               MZ   @ @,0+X2
     LZDAAA    B    0+X1
    ****************************************************************  
    ** DIVISION SNIPPET                                           **
    ****************************************************************  
     
     LSEAAA    SBR  LTEAAA+3           * SETUP RETURN ADDRESS
     * POP DIVIDEND
               MCW  0+X2, LUEAAA
               SBR  X2, 15995+X2

     * POP DIVISOR
               MCW  0+X2, LVEAAA
               SBR  X2, 15995+X2


               B    *+17
               
               DCW  @00000@                
               DC   @00000000000@        

               ZA   LUEAAA, *-7         * PUT DIVIDEND INTO WORKING BL
               D    LVEAAA, *-19        * DIVIDE
               MZ   *-22, *-21          * KILL THE ZONE BIT
               MZ   *-29, *-34          * KILL THE ZONE BIT
               MCW  *-41, LWEAAA        * PICK UP ANSWER
               SW   *-44                * SO I CAN PICKUP REMAINDER
               MCW  *-46, LXEAAA        * GET REMAINDER
               CW   *-55                * CLEAR THE WM
               MZ   LWEAAA-1, LWEAAA    * CLEANUP QUOTIENT BITZONE
               MZ   LXEAAA-1, LXEAAA    * CLEANUP REMAINDER BITZONE
               
     * PUSH REMAINDER
               SBR  X2, 5+X2
               SW   15996+X2
               MCW  LXEAAA, 0+X2
               
     * PUSH QUOTIENT
               SBR  X2, 5+X2
               SW   15996+X2
               MCW  LWEAAA, 0+X2

     LTEAAA    B    000                 * JUMP BACK
               
     LVEAAA    DCW  00000               * DIVISOR
     LUEAAA    DCW  00000               * DIVIDEND
     LWEAAA    DCW  00000               * QUOTIENT
     LXEAAA    DCW  00000               * REMAINDER
     LLEAAA    SBR  X1
     * Casts a 5-digit number to a 3-digit address
     * make a copy of the top of the stack
               SW   15998+X2
               LCA  0+X2,3+X2
               CW   15998+X2
     * zero out the zone bits of our copy
               MZ   @0@,3+X2
               MZ   @0@,2+X2
               MZ   @0@,1+X2
     * set the low-order digit's zone bits
               C    @04000@,0+X2
               BL   LOEAAA
               C    @08000@,0+X2
               BL   LNEAAA
               C    @12000@,0+X2
               BL   LMEAAA
               S    @12000@,0+X2
               MZ   @A@,3+X2
               B    LOEAAA
     LMEAAA    S    @08000@,0+X2
               MZ   @I@,3+X2
               B    LOEAAA
     LNEAAA    S    @04000@,0+X2
               MZ   @S@,3+X2
     * For some reason the zone bits get set - it still works though.
     LOEAAA    C    @01000@,0+X2
               BL   LREAAA
               C    @02000@,0+X2
               BL   LQEAAA
               C    @03000@,0+X2
               BL   LPEAAA
               MZ   @A@,1+X2
               B    LREAAA
     LPEAAA    MZ   @I@,1+X2
               B    LREAAA
     LQEAAA    MZ   @S@,1+X2
     LREAAA    LCA  3+X2,15998+X2
               SBR  X2,15998+X2
               B    0+X1
     LLFAAA    SBR  X1
     * Casts a 3-digit address to a 5-digit number
     * Make room on the stack for an int
               MA   @002@,X2
     * make a copy of the top of the stack
               LCA  15998+X2,3+X2
     * Now zero out the top of the stack
               LCA  @00000@,0+X2
     * Now copy back, shifted over 2 digits
               MCW  3+X2,0+X2
     * Now zero out the zone bits on the stack
               MZ   @0@,0+X2
               MZ   @0@,15999+X2
               MZ   @0@,15998+X2
     * check the high-order digit's zone bits
               BWZ  LMFAAA,1+X2,S
               BWZ  LNFAAA,1+X2,K
               BWZ  LOFAAA,1+X2,B
               B    LPFAAA
     LMFAAA    A    @01000@,0+X2
               B    LPFAAA
     LNFAAA    A    @02000@,0+X2
               B    LPFAAA
     LOFAAA    A    @03000@,0+X2
     LPFAAA    BWZ  LQFAAA,3+X2,S
               BWZ  LRFAAA,3+X2,K
               BWZ  LSFAAA,3+X2,B
               B    LTFAAA
     LQFAAA    A    @04000@,0+X2
               B    LTFAAA
     LRFAAA    A    @08000@,0+X2
               B    LTFAAA
     LSFAAA    A    @12000@,0+X2
     LTFAAA    B    0+X1

     LWDAAA    DCW  @I9G@
     LDFAAA    DCW  @100000@
     LZFAAA    DCW  @B@
     LBIAAA    DCW  @02V@
     LHGAAA    DCW  @16Y@
     LFHAAA    DCW  @I8G@
     LCGAAA    DCW  @13U@
     LXHAAA    DCW  @00010@
     LVDAAA    DCW  @006@
     LGGAAA    DCW  @16/@
     LGFAAA    DCW  @00V@
     LGEAAA    DCW  @I9B@
     LCHAAA    DCW  @013@
     LLGAAA    DCW  @18'@
     LHFAAA    DCW  @07Z@
     LAEAAA    DCW  @00000@
     LUFAAA    DCW  @09V@
     LSDAAA    DCW  @00001@
     LSGAAA    DCW  @21U@
     LFIAAA    DCW  @02Y@
     LDHAAA    DCW  @03Y@
     LWFAAA    DCW  @10Y@
     LAFAAA    DCW  @I8F@
     LUDAAA    DCW  @003@
     LXFAAA    DCW  @11U@
     LEGAAA    DCW  @14X@
     LGHAAA    DCW  @007@
     LDGAAA    DCW  @14'@
     LKGAAA    DCW  @05U@
     LRGAAA    DCW  @016@
     LIFAAA    DCW  @00111@
     LYHAAA    DCW  @I9C@
     LKFAAA    DCW  @08Y@
     LFFAAA    DCW  @00019@
     LJFAAA    DCW  @021@
     LBGAAA    DCW  @12Y@
     LEIAAA    DCW  @ @
     LPGAAA    DCW  @011@
     LYGAAA    DCW  @0000J@
     LMGAAA    DCW  @18W@
     LEFAAA    DCW  @00042@
     LEEAAA    DCW  @-@
     LWHAAA    DCW  @D@
     LHEAAA    DCW  @I9I@
     LOGAAA    DCW  @00002@
     LQGAAA    DCW  @20T@
     LLHAAA    DCW  @%@
     LUGAAA    DCW  @I7I@
     LGIAAA    DCW  @201@
     LZGAAA    DCW  @008@
     LKEAAA    DCW  @0@
     LNGAAA    DCW  @19S@
     LYFAAA    DCW  @12/@
     LEHAAA    DCW  @04U@
     LTHAAA    DCW  @S@
     LXGAAA    DCW  @I9D@
     LFEAAA    DCW  @001@
     LIGAAA    DCW  @17U@
     LFGAAA    DCW  @15U@
     LRDAAA    DCW  @00W@
     LQHAAA    DCW  @C@
     LAGAAA    DCW  @00003@
     LXDAAA    DCW  @005@
     LVFAAA    DCW  @10S@
     LTDAAA    DCW  @014@
     LTGAAA    DCW  @22V@
     LDEAAA    DCW  @I9E@
     LJGAAA    DCW  @00222@
     LJIAAA    DCW  @333@

               END  START              * End of program code.
