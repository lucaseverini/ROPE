     ****************************************************************
     ***  test_printf.s
     ***  Generated by Small-C Compiler on 3-May-2015 12:51:43 AM
     ****************************************************************
     ****************************************************************

     READ      EQU  001                * Read area
     PUNCH     EQU  101                * Punch area
     PRINT     EQU  201                * Print area
     
     PRCPOS    DCW  000                * char position in print area
     PUCPOS    DCW  000                * char position in punch area
     PUNSIZ    DCW  @080@              * Size of punch area
     PRTSIZ    DCW  @132@              * Size of print area
     EOS       DCW  @'@                * End Of String char
     EOL       DCW  @;@                * End Of Line char

               ORG  87
     X1        DSA  0                  * Index Register 1
               ORG  92
     X2        DSA  0                  * Index Register 2 (stack pointer)
               ORG  97
     X3        DSA  0                  * Index Register 3 (stack frame pointer)
     
     ****************************************************************
     
     * GLOBAL/STATIC DATA AND VARIABLES
     * seed size:5 offset:700
     * CONST_STR_LITERAL_1 size:17 offset:705
     * __putchar_pos size:3 offset:722
     * __putchar_last size:3 offset:725
     * __getCharPosition size:3 offset:728
     * x size:5 offset:731
     * CONST_STR_LITERAL_8 size:4 offset:736
     * CONST_STR_LITERAL_9 size:4 offset:740
     * CONST_STR_LITERAL_10 size:4 offset:744

               ORG  700                * seed
               DCW  @69105@

               ORG  705                * CONST_STR_LITERAL_1
               DCW  @0@
               DCW  @1@
               DCW  @2@
               DCW  @3@
               DCW  @4@
               DCW  @5@
               DCW  @6@
               DCW  @7@
               DCW  @8@
               DCW  @9@
               DCW  @A@
               DCW  @B@
               DCW  @C@
               DCW  @D@
               DCW  @E@
               DCW  @F@
               DCW  @'@

               ORG  722                * __putchar_pos
               DCW  @201@

               ORG  725                * __putchar_last
               DCW  @200@

               ORG  728                * __getCharPosition
               DCW  @081@

               ORG  731                * x
               DCW  @00000@

               ORG  736                * CONST_STR_LITERAL_8
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  740                * CONST_STR_LITERAL_9
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  744                * CONST_STR_LITERAL_10
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

     * START POSITION OF PROGRAM CODE
               ORG  748
     START     NOP                     * Program starts here

     * SET X2 TO BE THE STACK POINTER (STACK GROWS UPWARD)
               SBR  X2,399             * Set X2 to stack pointer value
               MCW  X2,X3              * Copy stack pointer in X3

               B    LDFAAA             * Jump to function main
               H                       * Program executed. System halts

     ********************************************************************************
     * Function : main
     ********************************************************************************
     LDFAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LEFAAA]
     * i size:5 offset:3

               LCA  LTFAAA,8+X3        * Load int 1 into memory 8+X3
     * Push (8)
               MA   LJGAAA,X2          * Add 8 to stack pointer

     * Switch [switch ((++i))]
     * PreIncrement((++i)
     * Push (LJGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LJGAAA,0+X2        * Load data 008 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
               A    LTFAAA,0+X1        * Preincrement memory at X1
     * Push (0+X1:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * Constant (1 : LTFAAA)
     * Push (LTFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 00001 in stack
               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BU   LKGAAA             * If different jump to next Case compare
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               B    LLGAAA             * Jump to Case: 1
     LKGAAA    NOP                     * Compare to Case: 2
     * Constant (2 : LMGAAA)
     * Push (LMGAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LMGAAA,0+X2        * Load data 00002 in stack
               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BU   LNGAAA             * If different jump to next Case compare
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               B    LOGAAA             * Jump to Case: 2
     LNGAAA    NOP                     * Compare to Case: 3
     * Constant (3 : LPGAAA)
     * Push (LPGAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LPGAAA,0+X2        * Load data 00003 in stack
               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BU   LQGAAA             * If different jump to next Case compare
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               B    LRGAAA             * Jump to Case: 3
     LQGAAA    NOP                     * End of Switch Cases
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               B    LSGAAA             * Jump to Default

     ***************************************
     * Begin [Block ending at LFFAAA]

     * Case: 1
     LLGAAA    NOP  
     * Assignment (i = (i + 1))
     * Addition (i + 1)
     * Local Variable (i : 8+X3)
     * Push (8+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  8+X3,0+X2          * Load memory 8+X3 in stack
     * Constant (1 : LTFAAA)
     * Push (LTFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 00001 in stack
               A    0+X2,15995+X2      * Add stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Push (LJGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LJGAAA,0+X2        * Load data 008 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Assignment (i = (i + 1))

               B    LGFAAA             * Break out of the switch block
     * Case: 2
     LOGAAA    NOP  
     * Assignment (i = (i + 2))
     * Addition (i + 2)
     * Local Variable (i : 8+X3)
     * Push (8+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  8+X3,0+X2          * Load memory 8+X3 in stack
     * Constant (2 : LMGAAA)
     * Push (LMGAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LMGAAA,0+X2        * Load data 00002 in stack
               A    0+X2,15995+X2      * Add stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Push (LJGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LJGAAA,0+X2        * Load data 008 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Assignment (i = (i + 2))

               B    LGFAAA             * Break out of the switch block
     * Case: 3
     LRGAAA    NOP  
     * Assignment (i = (i + 3))
     * Addition (i + 3)
     * Local Variable (i : 8+X3)
     * Push (8+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  8+X3,0+X2          * Load memory 8+X3 in stack
     * Constant (3 : LPGAAA)
     * Push (LPGAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LPGAAA,0+X2        * Load data 00003 in stack
               A    0+X2,15995+X2      * Add stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Push (LJGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LJGAAA,0+X2        * Load data 008 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Assignment (i = (i + 3))

               B    LGFAAA             * Break out of the switch block
     * Default
     LSGAAA    NOP  
     * Assignment (i = (i + 4))
     * Addition (i + 4)
     * Local Variable (i : 8+X3)
     * Push (8+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  8+X3,0+X2          * Load memory 8+X3 in stack
     * Constant (4 : LTGAAA)
     * Push (LTGAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTGAAA,0+X2        * Load data 00004 in stack
               A    0+X2,15995+X2      * Add stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Push (LJGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LJGAAA,0+X2        * Load data 008 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Assignment (i = (i + 4))

               B    LGFAAA             * Break out of the switch block
     LFFAAA    NOP                     * Last block instruction
     * End [Block ending at LFFAAA]
     ***************************************

     LGFAAA    NOP                     * Last switch block instruction
     * End Switch ((++i))

     * Function Call printf(CONST_STR_LITERAL_8, i)
     * Push (5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
     * Local Variable (i : 8+X3)
     * Push (8+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  8+X3,0+X2          * Load memory 8+X3 in stack
     * Static Array (CONST_STR_LITERAL_8:char [4])
     * Push (LUGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LUGAAA,0+X2        * Load data 736 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LAEAAA             * Jump to function printf

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Function Call printf(CONST_STR_LITERAL_8, i)

     * While [while ((i < 20)) [Block ending at LHFAAA] top:LIFAAA bottom:LJFAAA]
     LIFAAA    NOP                     * Top of While
     * Less (i < 20)
     * Local Variable (i : 8+X3)
     * Push (8+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  8+X3,0+X2          * Load memory 8+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Constant (20 : LVGAAA)
     * Push (LVGAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LVGAAA,0+X2        * Load data 00020 in stack
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               MCW  LWFAAA,0+X2        * Move 0 in stack
               BL   LWGAAA             * Jump if less
               B    LXGAAA             * Jump to End
     LWGAAA    MCW  LTFAAA,0+X2        * Move 1 in stack
     LXGAAA    NOP                     * End of Less
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LJFAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LHFAAA]

     * Function Call printf(CONST_STR_LITERAL_9, i)
     * Push (5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
     * Local Variable (i : 8+X3)
     * Push (8+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  8+X3,0+X2          * Load memory 8+X3 in stack
     * Static Array (CONST_STR_LITERAL_9:char [4])
     * Push (LYGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LYGAAA,0+X2        * Load data 740 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LAEAAA             * Jump to function printf

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Function Call printf(CONST_STR_LITERAL_9, i)

     LHFAAA    NOP                     * Last block instruction
     * End [Block ending at LHFAAA]
     ***************************************

               B    LIFAAA             * Jump to top of While

     LJFAAA    NOP                     * Bottom of While
     * End While [while ((i < 20)) [Block ending at LHFAAA] top:LIFAAA bottom:LJFAAA]

     * Function Call printf(CONST_STR_LITERAL_10, 20000)
     * Push (5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
     * Constant (20000 : LZGAAA)
     * Push (LZGAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LZGAAA,0+X2        * Load data 20000 in stack
     * Static Array (CONST_STR_LITERAL_10:char [4])
     * Push (LAHAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LAHAAA,0+X2        * Load data 744 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LAEAAA             * Jump to function printf

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Function Call printf(CONST_STR_LITERAL_10, 20000)

     LEFAAA    NOP                     * Last block instruction
     * Pop (8)
               MA   LBGAAA,X2          * Add -8 to stack pointer
     * End [Block ending at LEFAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : main
     ********************************************************************************

     ********************************************************************************
     * Function : genRand
     ********************************************************************************
     LBAAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LCAAAA]

     * Push (3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
     * Assignment (seed = (((42 * seed) + 19) % 100000))
     * Modulo (%) (((42 * seed) + 19) % 100000)
     * Constant (100000 : LLFAAA)
     * Push (LLFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LLFAAA,0+X2        * Load data 100000 in stack
     * Addition ((42 * seed) + 19)
     * Multiply (42 * seed)
     * Constant (42 : LNFAAA)
     * Push (LNFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LNFAAA,0+X2        * Load data 00042 in stack
     * Static Variable (seed : 704)
     * Push (704:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  704,0+X2           * Load memory 704 in stack
               M    15995+X2,6+X2      * Multiply stack at -5 to stack at 6
               SW   2+X2               * Set WM in stack at 2
               LCA  6+X2,15995+X2      * Load stack at 6 to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Constant (19 : LPFAAA)
     * Push (LPFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LPFAAA,0+X2        * Load data 00019 in stack
               A    0+X2,15995+X2      * Add stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               B    SNPDIV             * Jump to snippet SNIP_DIV

     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Push (LQFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LQFAAA,0+X2        * Load data 704 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Assignment (seed = (((42 * seed) + 19) % 100000))

     * Put on stack return value (seed)
     * Static Variable (seed : 704)
     * Push (704:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  704,0+X2           * Load memory 704 in stack
     * Pop (15997+X3:5)
               LCA  0+X2,15997+X3      * Load stack in 15997+X3
               MA   LOFAAA,X2          * Add -5 to stack pointer

     LCAAAA    NOP                     * Last block instruction
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End [Block ending at LCAAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : genRand
     ********************************************************************************

     ********************************************************************************
     * Function : itoa
     ********************************************************************************
     LYAAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LZAAAA]
     * start size:3 offset:3
     * digits size:3 offset:6
     * exp size:5 offset:9

               LCA  LSFAAA,9+X3        * Load *char 705 into memory 9+X3
               LCA  LTFAAA,14+X3       * Load int 1 into memory 14+X3
     * Push (14)
               MA   LUFAAA,X2          * Add 14 to stack pointer
     * Assignment (start = str)
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  15992+X3,0+X2      * Load memory 15992+X3 in stack
     * Push (LVFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LVFAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (start = str)

     * If [if ((value < 0) then [Block ending at LABAAA] else [if ((value == 0) then [Block ending at LBBAAA]]]
     * Less (value < 0)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Constant (0 : LWFAAA)
     * Push (LWFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LWFAAA,0+X2        * Load data 00000 in stack
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               MCW  LWFAAA,0+X2        * Move 0 in stack
               BL   LXFAAA             * Jump if less
               B    LYFAAA             * Jump to End
     LXFAAA    MCW  LTFAAA,0+X2        * Move 1 in stack
     LYFAAA    NOP                     * End of Less
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LDBAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LABAAA]

     * Assignment ((*(str++)) = '-')
     * Constant ('-' : LZFAAA)
     * Push (LZFAAA:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  LZFAAA,0+X2        * Load data - in stack
     * PostIncrement (str++)
     * Push (LBGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LBGAAA,0+X2        * Load data I9B in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LAGAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * End Assignment ((*(str++)) = '-')

     * Assignment (value = (-value))
     * Negate (-value)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               ZS   0+X2
               B    CLNNMN             * Jump to snippet clean_number

     * Push (LRFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LRFAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Assignment (value = (-value))

     LABAAA    NOP                     * Last block instruction
     * End [Block ending at LABAAA]
     ***************************************

               B    LEBAAA             * Jump when true
     LDBAAA    NOP                     * Executed when False
     * If [if ((value == 0) then [Block ending at LBBAAA]]
     * Equal (value == 0)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Constant (0 : LWFAAA)
     * Push (LWFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LWFAAA,0+X2        * Load data 00000 in stack
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Push (LWFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LWFAAA,0+X2        * Load data 00000 in stack
               BE   LDGAAA             * Jump if equal
               B    LEGAAA             * Jump to End
     LDGAAA    MCW  LTFAAA,0+X2        * Move 1 in stack
     LEGAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LCBAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LBBAAA]

     * Assignment ((str[0]) = '0')
     * Constant ('0' : LFGAAA)
     * Push (LFGAAA:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  LFGAAA,0+X2        * Load data 0 in stack
     * SubScript (str[0])
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  15992+X3,0+X2      * Load memory 15992+X3 in stack
     * End SubScript (str[0])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * End Assignment ((str[0]) = '0')

     * Assignment ((str[1]) = '\0')
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
     * SubScript (str[1])
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  15992+X3,0+X2      * Load memory 15992+X3 in stack
               A    LTFAAA,0+X2        * Add offset 1 to point element 1
     * End SubScript (str[1])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * End Assignment ((str[1]) = '\0')

     * Return to LZAAAA with return value start
     * Put on stack return value (start)
     * Local Variable (start : 6+X3)
     * Push (6+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (15984+X3:3)
               LCA  0+X2,15984+X3      * Load stack in 15984+X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
               B    LZAAAA             * Jump to end of function block

     LBBAAA    NOP                     * Last block instruction
     * End [Block ending at LBBAAA]
     ***************************************

     LCBAAA    NOP                     * Executed when False
     * End If [if ((value == 0) then [Block ending at LBBAAA]]

     LEBAAA    NOP                     * Executed when True
     * End If [if ((value < 0) then [Block ending at LABAAA] else [if ((value == 0) then [Block ending at LBBAAA]]]

     * While [while ((exp <= (value / base))) [Block ending at LFBAAA] top:LGBAAA bottom:LHBAAA]
     LGBAAA    NOP                     * Top of While
     * LessOrEqual (exp <= (value / base))
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Divide (value / base)
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  15989+X3,0+X2      * Load memory 15989+X3 in stack
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               B    SNPDIV             * Jump to snippet SNIP_DIV

               MCW  0+X2,15995+X2      * Move stack in stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               MCW  LTFAAA,0+X2        * Move 1 in stack
               BH   LGGAAA             * Jump if less or equal
               B    LHGAAA             * Jump to End
     LGGAAA    MCW  LWFAAA,0+X2        * Move 0 in stack
     LHGAAA    NOP                     * End of LessOrEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LHBAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LFBAAA]

     * Assignment (exp = (exp * base))
     * Multiply (exp * base)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  15989+X3,0+X2      * Load memory 15989+X3 in stack
               M    15995+X2,6+X2      * Multiply stack at -5 to stack at 6
               SW   2+X2               * Set WM in stack at 2
               LCA  6+X2,15995+X2      * Load stack at 6 to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Push (LUFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LUFAAA,0+X2        * Load data 014 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Assignment (exp = (exp * base))

     LFBAAA    NOP                     * Last block instruction
     * End [Block ending at LFBAAA]
     ***************************************

               B    LGBAAA             * Jump to top of While

     LHBAAA    NOP                     * Bottom of While
     * End While [while ((exp <= (value / base))) [Block ending at LFBAAA] top:LGBAAA bottom:LHBAAA]

     * While [while (exp) [Block ending at LIBAAA] top:LJBAAA bottom:LKBAAA]
     LJBAAA    NOP                     * Top of While
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LKBAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LIBAAA]

     * Assignment ((*(str++)) = (digits[(value / exp)]))
     * SubScript (digits[(value / exp)])
     * Local Variable (digits : 9+X3)
     * Push (9+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  9+X3,0+X2          * Load memory 9+X3 in stack
     * Divide (value / exp)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               B    SNPDIV             * Jump to snippet SNIP_DIV

               MCW  0+X2,15995+X2      * Move stack in stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Put raw index on the stack
     * Push (LTFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 00001 in stack
               M    15995+X2,6+X2      * Multiply stack at -5 to stack at 6
               SW   2+X2               * Set WM in stack at 2
               LCA  6+X2,15995+X2      * Load stack at 6 in stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Stack top is now array index
               B    NMNPTR             * Jump to snippet number_to_pointer

               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Stack top is location in array now
     * End SubScript (digits[(value / exp)])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * PostIncrement (str++)
     * Push (LBGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LBGAAA,0+X2        * Load data I9B in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LAGAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * End Assignment ((*(str++)) = (digits[(value / exp)]))

     * Assignment (value = (value % exp))
     * Modulo (%) (value % exp)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               B    SNPDIV             * Jump to snippet SNIP_DIV

     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Push (LRFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LRFAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Assignment (value = (value % exp))

     * Assignment (exp = (exp / base))
     * Divide (exp / base)
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  15989+X3,0+X2      * Load memory 15989+X3 in stack
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
               B    SNPDIV             * Jump to snippet SNIP_DIV

               MCW  0+X2,15995+X2      * Move stack in stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Push (LUFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LUFAAA,0+X2        * Load data 014 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Assignment (exp = (exp / base))

     LIBAAA    NOP                     * Last block instruction
     * End [Block ending at LIBAAA]
     ***************************************

               B    LJBAAA             * Jump to top of While

     LKBAAA    NOP                     * Bottom of While
     * End While [while (exp) [Block ending at LIBAAA] top:LJBAAA bottom:LKBAAA]

     * Assignment ((*str) = '\0')
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  15992+X3,0+X2      * Load memory 15992+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * End Assignment ((*str) = '\0')

     * Put on stack return value (start)
     * Local Variable (start : 6+X3)
     * Push (6+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (15984+X3:3)
               LCA  0+X2,15984+X3      * Load stack in 15984+X3
               MA   LRFAAA,X2          * Add -3 to stack pointer

     LZAAAA    NOP                     * Last block instruction
     * Pop (14)
               MA   LIGAAA,X2          * Add -14 to stack pointer
     * End [Block ending at LZAAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : itoa
     ********************************************************************************

     ********************************************************************************
     * Function : printf
     ********************************************************************************
     LAEAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LBEAAA]
     * arg size:3 offset:3
     * c size:1 offset:6
     * addrP size:3 offset:7
     * addrC size:1 offset:10

     * Push (11)
               MA   LBHAAA,X2          * Add 11 to stack pointer
     * Assignment (arg = ((*char) (( &cformat_str ) + 15997)))
     * Addition (( &cformat_str ) + 15997)
     * AddressOf ( &cformat_str )
     * Push (LRFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LRFAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Constant (15997 : LRFAAA)
     * Push (LRFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LRFAAA,0+X2        * Load data I9G in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (LVFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LVFAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (arg = ((*char) (( &cformat_str ) + 15997)))

     * While [while (((c = (*(cformat_str++))) != '\0')) [Block ending at LCEAAA] top:LXEAAA bottom:LYEAAA]
     LXEAAA    NOP                     * Top of While
     * NotEqual (!=) ((c = (*(cformat_str++))) != '\0')
     * Assignment (c = (*(cformat_str++)))
     * DereferenceExpression (*(cformat_str++))
     * PostIncrement (cformat_str++)
     * Push (LRFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LRFAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LAGAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*(cformat_str++))

     * Push (LEHAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LEHAAA,0+X2        * Load data 007 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
               LCA  0+X2,0+X1          * Load stack in memory X1
     * End Assignment (c = (*(cformat_str++)))

     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LTFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 00001 in stack
               BE   LCHAAA             * Jump if equal
               B    LDHAAA             * Jump to End
     LCHAAA    MCW  LWFAAA,0+X2        * Move 0 in stack
     LDHAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LYEAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LCEAAA]

     * If [if ((c != '%') then [Block ending at LDEAAA] else [Block ending at LEEAAA]]
     * NotEqual (!=) (c != '%')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('%' : LHHAAA)
     * Push (LHHAAA:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  LHHAAA,0+X2        * Load data % in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LTFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 00001 in stack
               BE   LFHAAA             * Jump if equal
               B    LGHAAA             * Jump to End
     LFHAAA    MCW  LWFAAA,0+X2        * Move 0 in stack
     LGHAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LVEAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LDEAAA]

     * Function Call putchar(c)
     * Push (5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LWCAAA             * Jump to function putchar

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Function Call putchar(c)

     LDEAAA    NOP                     * Last block instruction
     * End [Block ending at LDEAAA]
     ***************************************

               B    LWEAAA             * Jump when true
     LVEAAA    NOP                     * Executed when False

     ***************************************
     * Begin [Block ending at LEEAAA]

     * Assignment (c = (*(cformat_str++)))
     * DereferenceExpression (*(cformat_str++))
     * PostIncrement (cformat_str++)
     * Push (LRFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LRFAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LAGAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*(cformat_str++))

     * Push (LEHAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LEHAAA,0+X2        * Load data 007 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * End Assignment (c = (*(cformat_str++)))

     * If [if ((c == '%') then [Block ending at LFEAAA] else [if ((c == 'C') then [Block ending at LGEAAA] else [if ((c == 'S') then [Block ending at LHEAAA] else [if ((c == 'D') then [Block ending at LIEAAA] else [if ((c == 'P') then [Block ending at LJEAAA] else [Block ending at LKEAAA]]]]]]
     * Equal (c == '%')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('%' : LHHAAA)
     * Push (LHHAAA:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  LHHAAA,0+X2        * Load data % in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LWFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LWFAAA,0+X2        * Load data 00000 in stack
               BE   LIHAAA             * Jump if equal
               B    LJHAAA             * Jump to End
     LIHAAA    MCW  LTFAAA,0+X2        * Move 1 in stack
     LJHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LTEAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LFEAAA]

     * Function Call putchar('%')
     * Push (5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
     * Constant ('%' : LHHAAA)
     * Push (LHHAAA:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  LHHAAA,0+X2        * Load data % in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LWCAAA             * Jump to function putchar

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Function Call putchar('%')

     LFEAAA    NOP                     * Last block instruction
     * End [Block ending at LFEAAA]
     ***************************************

               B    LUEAAA             * Jump when true
     LTEAAA    NOP                     * Executed when False
     * If [if ((c == 'C') then [Block ending at LGEAAA] else [if ((c == 'S') then [Block ending at LHEAAA] else [if ((c == 'D') then [Block ending at LIEAAA] else [if ((c == 'P') then [Block ending at LJEAAA] else [Block ending at LKEAAA]]]]]
     * Equal (c == 'C')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('C' : LMHAAA)
     * Push (LMHAAA:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  LMHAAA,0+X2        * Load data C in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LWFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LWFAAA,0+X2        * Load data 00000 in stack
               BE   LKHAAA             * Jump if equal
               B    LLHAAA             * Jump to End
     LKHAAA    MCW  LTFAAA,0+X2        * Move 1 in stack
     LLHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LREAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LGEAAA]

     * Function Call putchar((*arg))
     * Push (5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
     * DereferenceExpression (*arg)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*arg)

     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LWCAAA             * Jump to function putchar

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Function Call putchar((*arg))

     * Assignment (arg = (arg + 15999))
     * Addition (arg + 15999)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Constant (15999 : LCGAAA)
     * Push (LCGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LCGAAA,0+X2        * Load data I9I in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (LVFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LVFAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (arg = (arg + 15999))

     LGEAAA    NOP                     * Last block instruction
     * End [Block ending at LGEAAA]
     ***************************************

               B    LSEAAA             * Jump when true
     LREAAA    NOP                     * Executed when False
     * If [if ((c == 'S') then [Block ending at LHEAAA] else [if ((c == 'D') then [Block ending at LIEAAA] else [if ((c == 'P') then [Block ending at LJEAAA] else [Block ending at LKEAAA]]]]
     * Equal (c == 'S')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('S' : LPHAAA)
     * Push (LPHAAA:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  LPHAAA,0+X2        * Load data S in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LWFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LWFAAA,0+X2        * Load data 00000 in stack
               BE   LNHAAA             * Jump if equal
               B    LOHAAA             * Jump to End
     LNHAAA    MCW  LTFAAA,0+X2        * Move 1 in stack
     LOHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LPEAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LHEAAA]

     * Function Call puts((*((**char) arg)))
     * Push (5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
     * DereferenceExpression (*((**char) arg))
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*((**char) arg))

     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LHDAAA             * Jump to function puts

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Function Call puts((*((**char) arg)))

     * Assignment (arg = (arg + 15997))
     * Addition (arg + 15997)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Constant (15997 : LRFAAA)
     * Push (LRFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LRFAAA,0+X2        * Load data I9G in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (LVFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LVFAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (arg = (arg + 15997))

     LHEAAA    NOP                     * Last block instruction
     * End [Block ending at LHEAAA]
     ***************************************

               B    LQEAAA             * Jump when true
     LPEAAA    NOP                     * Executed when False
     * If [if ((c == 'D') then [Block ending at LIEAAA] else [if ((c == 'P') then [Block ending at LJEAAA] else [Block ending at LKEAAA]]]
     * Equal (c == 'D')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('D' : LSHAAA)
     * Push (LSHAAA:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  LSHAAA,0+X2        * Load data D in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LWFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LWFAAA,0+X2        * Load data 00000 in stack
               BE   LQHAAA             * Jump if equal
               B    LRHAAA             * Jump to End
     LQHAAA    MCW  LTFAAA,0+X2        * Move 1 in stack
     LRHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LNEAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LIEAAA]
     * a size:7 offset:11

     * Push (7)
               MA   LEHAAA,X2          * Add 7 to stack pointer
     * Function Call itoa((*((*int) arg)), a, 10)
     * Push (3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
     * Constant (10 : LTHAAA)
     * Push (LTHAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTHAAA,0+X2        * Load data 00010 in stack
     * Local Array (a:char [7])
     * Push (LUHAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LUHAAA,0+X2        * Load data 012 in stack
               MA   X3,0+X2            * Add X3 to stack
     * DereferenceExpression (*((*int) arg))
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*((*int) arg))

     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LYAAAA             * Jump to function itoa

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Function Call itoa((*((*int) arg)), a, 10)

     * Function Call puts(a)
     * Push (5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
     * Local Array (a:char [7])
     * Push (LUHAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LUHAAA,0+X2        * Load data 012 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LHDAAA             * Jump to function puts

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Function Call puts(a)

     * Assignment (arg = (arg + 15995))
     * Addition (arg + 15995)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Constant (15995 : LOFAAA)
     * Push (LOFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LOFAAA,0+X2        * Load data I9E in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (LVFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LVFAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (arg = (arg + 15995))

     LIEAAA    NOP                     * Last block instruction
     * Pop (7)
               MA   LVHAAA,X2          * Add -7 to stack pointer
     * End [Block ending at LIEAAA]
     ***************************************

               B    LOEAAA             * Jump when true
     LNEAAA    NOP                     * Executed when False
     * If [if ((c == 'P') then [Block ending at LJEAAA] else [Block ending at LKEAAA]]
     * Equal (c == 'P')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('P' : LYHAAA)
     * Push (LYHAAA:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  LYHAAA,0+X2        * Load data P in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LWFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LWFAAA,0+X2        * Load data 00000 in stack
               BE   LWHAAA             * Jump if equal
               B    LXHAAA             * Jump to End
     LWHAAA    MCW  LTFAAA,0+X2        * Move 1 in stack
     LXHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LLEAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LJEAAA]

     * Assignment (addrP = arg)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Push (LZHAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LZHAAA,0+X2        * Load data 010 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (addrP = arg)

     * Assignment (addrC = (*addrP))
     * DereferenceExpression (*addrP)
     * Local Variable (addrP : 10+X3)
     * Push (10+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  10+X3,0+X2         * Load memory 10+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*addrP)

     * Push (LBHAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LBHAAA,0+X2        * Load data 011 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * End Assignment (addrC = (*addrP))

     * Function Call putchar(addrC)
     * Push (5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
     * Local Variable (addrC : 11+X3)
     * Push (11+X3:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  11+X3,0+X2         * Load memory 11+X3 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LWCAAA             * Jump to function putchar

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Function Call putchar(addrC)

     * Start asm block
               W    
     * End asm block
     * Start asm block
               W    
     * End asm block
     * Start asm block
               W    
     * End asm block
     * Assignment (arg = (arg + 15999))
     * Addition (arg + 15999)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Constant (15999 : LCGAAA)
     * Push (LCGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LCGAAA,0+X2        * Load data I9I in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (LVFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LVFAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (arg = (arg + 15999))

     LJEAAA    NOP                     * Last block instruction
     * End [Block ending at LJEAAA]
     ***************************************

               B    LMEAAA             * Jump when true
     LLEAAA    NOP                     * Executed when False

     ***************************************
     * Begin [Block ending at LKEAAA]

     * Return to LEEAAA with no return value
               B    LEEAAA             * Jump to end of function block

     LKEAAA    NOP                     * Last block instruction
     * End [Block ending at LKEAAA]
     ***************************************

     LMEAAA    NOP                     * Executed when True
     * End If [if ((c == 'P') then [Block ending at LJEAAA] else [Block ending at LKEAAA]]

     LOEAAA    NOP                     * Executed when True
     * End If [if ((c == 'D') then [Block ending at LIEAAA] else [if ((c == 'P') then [Block ending at LJEAAA] else [Block ending at LKEAAA]]]

     LQEAAA    NOP                     * Executed when True
     * End If [if ((c == 'S') then [Block ending at LHEAAA] else [if ((c == 'D') then [Block ending at LIEAAA] else [if ((c == 'P') then [Block ending at LJEAAA] else [Block ending at LKEAAA]]]]

     LSEAAA    NOP                     * Executed when True
     * End If [if ((c == 'C') then [Block ending at LGEAAA] else [if ((c == 'S') then [Block ending at LHEAAA] else [if ((c == 'D') then [Block ending at LIEAAA] else [if ((c == 'P') then [Block ending at LJEAAA] else [Block ending at LKEAAA]]]]]

     LUEAAA    NOP                     * Executed when True
     * End If [if ((c == '%') then [Block ending at LFEAAA] else [if ((c == 'C') then [Block ending at LGEAAA] else [if ((c == 'S') then [Block ending at LHEAAA] else [if ((c == 'D') then [Block ending at LIEAAA] else [if ((c == 'P') then [Block ending at LJEAAA] else [Block ending at LKEAAA]]]]]]

     LEEAAA    NOP                     * Last block instruction
     * End [Block ending at LEEAAA]
     ***************************************

     LWEAAA    NOP                     * Executed when True
     * End If [if ((c != '%') then [Block ending at LDEAAA] else [Block ending at LEEAAA]]

     LCEAAA    NOP                     * Last block instruction
     * End [Block ending at LCEAAA]
     ***************************************

               B    LXEAAA             * Jump to top of While

     LYEAAA    NOP                     * Bottom of While
     * End While [while (((c = (*(cformat_str++))) != '\0')) [Block ending at LCEAAA] top:LXEAAA bottom:LYEAAA]

     LBEAAA    NOP                     * Last block instruction
     * Pop (11)
               MA   LAIAAA,X2          * Add -11 to stack pointer
     * End [Block ending at LBEAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : printf
     ********************************************************************************

     ********************************************************************************
     * Function : putchar
     ********************************************************************************
     LWCAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LXCAAA]

     * Push (3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
     * If [if ((c != '\n') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]
     * NotEqual (!=) (c != '\n')
     * Parameter Variable (c : 15997+X3)
     * Push (15997+X3:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
     * Constant ('\n' : EOL)
     * Push (EOL:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  EOL,0+X2           * Load memory EOL in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LTFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 00001 in stack
               BE   LBIAAA             * Jump if equal
               B    LCIAAA             * Jump to End
     LBIAAA    MCW  LWFAAA,0+X2        * Move 0 in stack
     LCIAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LDDAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LYCAAA]

     * Assignment ((*(__putchar_pos++)) = c)
     * Parameter Variable (c : 15997+X3)
     * Push (15997+X3:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
     * PostIncrement (__putchar_pos++)
     * Push (LDIAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LDIAAA,0+X2        * Load data 724 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LAGAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * End Assignment ((*(__putchar_pos++)) = c)

     LYCAAA    NOP                     * Last block instruction
     * End [Block ending at LYCAAA]
     ***************************************

               B    LEDAAA             * Jump when true
     LDDAAA    NOP                     * Executed when False

     ***************************************
     * Begin [Block ending at LZCAAA]

     * While [while ((((int) __putchar_last) >= ((int) __putchar_pos))) [Block ending at LADAAA] top:LBDAAA bottom:LCDAAA]
     LBDAAA    NOP                     * Top of While
     * GreaterOrEqual (((int) __putchar_last) >= ((int) __putchar_pos))
     * Static Variable (__putchar_last : 727)
     * Push (727:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  727,0+X2           * Load memory 727 in stack
     * Cast Pointer(__putchar_last) to Number
               B    PTRNMN             * Jump to snippet pointer_to_number

               B    CLNNMN             * Jump to snippet clean_number

     * Static Variable (__putchar_pos : 724)
     * Push (724:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  724,0+X2           * Load memory 724 in stack
     * Cast Pointer(__putchar_pos) to Number
               B    PTRNMN             * Jump to snippet pointer_to_number

               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               MCW  LTFAAA,0+X2        * Move 1 in stack
               BL   LEIAAA             * Jump if greater or equal
               B    LFIAAA             * Jump to End
     LEIAAA    MCW  LWFAAA,0+X2        * Move 1 in stack
     LFIAAA    NOP                     * End of GreaterOrEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LCDAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LADAAA]

     * Assignment ((*(__putchar_last--)) = ' ')
     * Constant (' ' : LGIAAA)
     * Push (LGIAAA:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  LGIAAA,0+X2        * Load data   in stack
     * PostDecrement (__putchar_last--)
     * Push (LHIAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LHIAAA,0+X2        * Load data 727 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LCGAAA,0+X1        * Postdecrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * End Assignment ((*(__putchar_last--)) = ' ')

     LADAAA    NOP                     * Last block instruction
     * End [Block ending at LADAAA]
     ***************************************

               B    LBDAAA             * Jump to top of While

     LCDAAA    NOP                     * Bottom of While
     * End While [while ((((int) __putchar_last) >= ((int) __putchar_pos))) [Block ending at LADAAA] top:LBDAAA bottom:LCDAAA]

     * Assignment (__putchar_last = __putchar_pos)
     * Static Variable (__putchar_pos : 724)
     * Push (724:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  724,0+X2           * Load memory 724 in stack
     * Push (LHIAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LHIAAA,0+X2        * Load data 727 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (__putchar_last = __putchar_pos)

     * Assignment (__putchar_pos = 201)
     * Constant (201 : LIIAAA)
     * Push (LIIAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LIIAAA,0+X2        * Load data 201 in stack
     * Push (LDIAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LDIAAA,0+X2        * Load data 724 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (__putchar_pos = 201)

     * Start asm block
               W    
     * End asm block
     LZCAAA    NOP                     * Last block instruction
     * End [Block ending at LZCAAA]
     ***************************************

     LEDAAA    NOP                     * Executed when True
     * End If [if ((c != '\n') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]

     * If [if ((__putchar_pos == 333) then [Block ending at LFDAAA]]
     * Equal (__putchar_pos == 333)
     * Static Variable (__putchar_pos : 724)
     * Push (724:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  724,0+X2           * Load memory 724 in stack
     * Constant (333 : LLIAAA)
     * Push (LLIAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LLIAAA,0+X2        * Load data 333 in stack
               C    0+X2,15997+X2      * Compare stack to stack at -3
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (LWFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LWFAAA,0+X2        * Load data 00000 in stack
               BE   LJIAAA             * Jump if equal
               B    LKIAAA             * Jump to End
     LJIAAA    MCW  LTFAAA,0+X2        * Move 1 in stack
     LKIAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LGDAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LFDAAA]

     * Assignment (__putchar_last = __putchar_pos)
     * Static Variable (__putchar_pos : 724)
     * Push (724:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  724,0+X2           * Load memory 724 in stack
     * Push (LHIAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LHIAAA,0+X2        * Load data 727 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (__putchar_last = __putchar_pos)

     * Assignment (__putchar_pos = 201)
     * Constant (201 : LIIAAA)
     * Push (LIIAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LIIAAA,0+X2        * Load data 201 in stack
     * Push (LDIAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LDIAAA,0+X2        * Load data 724 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End Assignment (__putchar_pos = 201)

     * Start asm block
               W    
     * End asm block
     LFDAAA    NOP                     * Last block instruction
     * End [Block ending at LFDAAA]
     ***************************************

     LGDAAA    NOP                     * Executed when False
     * End If [if ((__putchar_pos == 333) then [Block ending at LFDAAA]]

     LXCAAA    NOP                     * Last block instruction
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End [Block ending at LXCAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : putchar
     ********************************************************************************

     ********************************************************************************
     * Function : puts
     ********************************************************************************
     LHDAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LIDAAA]

     * Push (3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
     * While [while (((*s) != '\0')) [Block ending at LJDAAA] top:LKDAAA bottom:LLDAAA]
     LKDAAA    NOP                     * Top of While
     * NotEqual (!=) ((*s) != '\0')
     * DereferenceExpression (*s)
     * Parameter Variable (s : 15997+X3)
     * Push (15997+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*s)

     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LTFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 00001 in stack
               BE   LMIAAA             * Jump if equal
               B    LNIAAA             * Jump to End
     LMIAAA    MCW  LWFAAA,0+X2        * Move 0 in stack
     LNIAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LLDAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LJDAAA]

     * Function Call putchar((*(s++)))
     * Push (5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
     * DereferenceExpression (*(s++))
     * PostIncrement (s++)
     * Push (LRFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LRFAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LAGAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*(s++))

     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LWCAAA             * Jump to function putchar

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * End Function Call putchar((*(s++)))

     LJDAAA    NOP                     * Last block instruction
     * End [Block ending at LJDAAA]
     ***************************************

               B    LKDAAA             * Jump to top of While

     LLDAAA    NOP                     * Bottom of While
     * End While [while (((*s) != '\0')) [Block ending at LJDAAA] top:LKDAAA bottom:LLDAAA]

     LIDAAA    NOP                     * Last block instruction
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End [Block ending at LIDAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : puts
     ********************************************************************************

     ********************************************************************************
     * Function : strcpy
     ********************************************************************************
     LJAAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LKAAAA]

     * Push (3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
     * While [while ((((*(dest++)) = (*(src++))) != '\0')) [] top:LLAAAA bottom:LMAAAA]
     LLAAAA    NOP                     * Top of While
     * NotEqual (!=) (((*(dest++)) = (*(src++))) != '\0')
     * Assignment ((*(dest++)) = (*(src++)))
     * DereferenceExpression (*(src++))
     * PostIncrement (src++)
     * Push (LQIAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LQIAAA,0+X2        * Load data I9D in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LAGAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*(src++))

     * PostIncrement (dest++)
     * Push (LRFAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LRFAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LAGAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
               LCA  0+X2,0+X1          * Load stack in memory X1
     * End Assignment ((*(dest++)) = (*(src++)))

     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LTFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 00001 in stack
               BE   LOIAAA             * Jump if equal
               B    LPIAAA             * Jump to End
     LOIAAA    MCW  LWFAAA,0+X2        * Move 0 in stack
     LPIAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LMAAAA,5+X2,       * Jump to bottom of While
               B    LLAAAA             * Jump to top of While

     LMAAAA    NOP                     * Bottom of While
     * End While [while ((((*(dest++)) = (*(src++))) != '\0')) [] top:LLAAAA bottom:LMAAAA]

     LKAAAA    NOP                     * Last block instruction
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * End [Block ending at LKAAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : strcpy
     ********************************************************************************

     ********************************************************************************
     * Function : strlen
     ********************************************************************************
     LFAAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LGAAAA]
     * len size:5 offset:3

               LCA  LRIAAA,8+X3        * Load int -1 into memory 8+X3
     * Push (8)
               MA   LJGAAA,X2          * Add 8 to stack pointer
     * While [while (((str[(++len)]) != '\0')) [] top:LHAAAA bottom:LIAAAA]
     LHAAAA    NOP                     * Top of While
     * NotEqual (!=) ((str[(++len)]) != '\0')
     * SubScript (str[(++len)])
     * Parameter Variable (str : 15997+X3)
     * Push (15997+X3:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
     * PreIncrement((++len)
     * Push (LJGAAA:3)
               MA   LKFAAA,X2          * Add 3 to stack pointer
               LCA  LJGAAA,0+X2        * Load data 008 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
               A    LTFAAA,0+X1        * Preincrement memory at X1
     * Push (0+X1:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * Put raw index on the stack
     * Push (LTFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 00001 in stack
               M    15995+X2,6+X2      * Multiply stack at -5 to stack at 6
               SW   2+X2               * Set WM in stack at 2
               LCA  6+X2,15995+X2      * Load stack at 6 in stack at -5
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
     * Stack top is now array index
               B    NMNPTR             * Jump to snippet number_to_pointer

               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Stack top is location in array now
     * End SubScript (str[(++len)])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LRFAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LAGAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LCGAAA,X2          * Add -1 to stack pointer
     * Push (LTFAAA:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 00001 in stack
               BE   LSIAAA             * Jump if equal
               B    LTIAAA             * Jump to End
     LSIAAA    MCW  LWFAAA,0+X2        * Move 0 in stack
     LTIAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LOFAAA,X2          * Add -5 to stack pointer
               BCE  LIAAAA,5+X2,       * Jump to bottom of While
               B    LHAAAA             * Jump to top of While

     LIAAAA    NOP                     * Bottom of While
     * End While [while (((str[(++len)]) != '\0')) [] top:LHAAAA bottom:LIAAAA]

     * Put on stack return value (len)
     * Local Variable (len : 8+X3)
     * Push (8+X3:5)
               MA   LMFAAA,X2          * Add 5 to stack pointer
               LCA  8+X3,0+X2          * Load memory 8+X3 in stack
     * Pop (15994+X3:5)
               LCA  0+X2,15994+X3      * Load stack in 15994+X3
               MA   LOFAAA,X2          * Add -5 to stack pointer

     LGAAAA    NOP                     * Last block instruction
     * Pop (8)
               MA   LBGAAA,X2          * Add -8 to stack pointer
     * End [Block ending at LGAAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : strlen
     ********************************************************************************
     ****************************************************************
     ** CAST NUMBER TO POINTER SNIPPET                             **
     ****************************************************************

     NMNPTR    SBR  X1
     * Casts a 5-digit number to a 3-digit address
     * make a copy of the top of the stack
               SW   15998+X2
               LCA  0+X2,3+X2
               CW   15998+X2
     * zero out the zone bits of our copy
               MZ   @0@,3+X2
               MZ   @0@,2+X2
               MZ   @0@,1+X2
     * set the low-order digit's zone bits
               C    @04000@,0+X2
               BL   NPHIGH
               C    @08000@,0+X2
               BL   NPLOZ
               C    @12000@,0+X2
               BL   NPLZO
               S    @12000@,0+X2
               MZ   @A@,3+X2
               B    NPHIGH
     NPLZO     S    @08000@,0+X2
               MZ   @I@,3+X2
               B    NPHIGH
     NPLOZ     S    @04000@,0+X2
               MZ   @S@,3+X2
     * For some reason the zone bits get set - it still works though.
     NPHIGH    C    @01000@,0+X2
               BL   NMPTRE
               C    @02000@,0+X2
               BL   NPHOZ
               C    @03000@,0+X2
               BL   NPHZO
               MZ   @A@,1+X2
               B    NMPTRE
     NPHZO     MZ   @I@,1+X2
               B    NMPTRE
     NPHOZ     MZ   @S@,1+X2
     NMPTRE    LCA  3+X2,15998+X2
               SBR  X2,15998+X2
               B    0+X1

     ****************************************************************
     ****************************************************************
     ** DIVISION SNIPPET                                           **
     ****************************************************************
     * SETUP RETURN ADDRESS
     SNPDIV    SBR  DIVEND+3

     * POP DIVIDEND
               MCW  0+X2,CDIV2
               SBR  X2,15995+X2

     * POP DIVISOR
               MCW  0+X2,CDIV1
               SBR  X2,15995+X2


               B    *+17               * Branch 17 places down?

               DCW  @00000@
               DC   @00000000000@

               ZA   CDIV2,*-7        * PUT DIVIDEND INTO WORKING BL
               D    CDIV1,*-19       * DIVIDE
               MZ   *-22,*-21        * KILL THE ZONE BIT
               MZ   *-29,*-34        * KILL THE ZONE BIT
               MCW  *-41,CDIV3       * PICK UP ANSWER
               SW   *-44              * SO I CAN PICKUP REMAINDER
               MCW  *-46,CDIV4       * GET REMAINDER
               CW   *-55              * CLEAR THE WM
               MZ   CDIV3-1,CDIV3    * CLEANUP QUOTIENT BITZONE
               MZ   CDIV4-1,CDIV4    * CLEANUP REMAINDER BITZONE

     * PUSH REMAINDER
               SBR  X2,5+X2
               SW   15996+X2
               MCW  CDIV4,0+X2

     * PUSH QUOTIENT
               SBR  X2,5+X2
               SW   15996+X2
               MCW  CDIV3,0+X2

     * JUMP BACK
     DIVEND    B    000

     * DIVISOR
     CDIV1     DCW  00000
     * DIVIDEND
     CDIV2     DCW  00000
     * QUOTIENT
     CDIV3     DCW  00000
     * REMAINDER
     CDIV4     DCW  00000

     ****************************************************************
     ****************************************************************
     ** CAST POINTER TO NUMBER SNIPPET                             **
     ****************************************************************

     PTRNMN    SBR  X1
     * Casts a 3-digit address to a 5-digit number
     * Make room on the stack for an int
               MA   @002@,X2
     * make a copy of the top of the stack
               LCA  15998+X2,3+X2
     * Now zero out the top of the stack
               LCA  @00000@,0+X2
     * Now copy back, shifted over 2 digits
               MCW  3+X2,0+X2
     * Now zero out the zone bits on the stack
               MZ   @0@,0+X2
               MZ   @0@,15999+X2
               MZ   @0@,15998+X2
     * check the high-order digit's zone bits
               BWZ  PNHOZ,1+X2,S
               BWZ  PNHZO,1+X2,K
               BWZ  PNHOO,1+X2,B
               B    PNLOW
     PNHOZ     A    @01000@,0+X2
               B    PNLOW
     PNHZO     A    @02000@,0+X2
               B    PNLOW
     PNHOO     A    @03000@,0+X2
     PNLOW     BWZ  PNLOZ,3+X2,S
               BWZ  PNLZO,3+X2,K
               BWZ  PNLOO,3+X2,B
               B    PTRNME
     PNLOZ     A    @04000@,0+X2
               B    PTRNME
     PNLZO     A    @08000@,0+X2
               B    PTRNME
     PNLOO     A    @12000@,0+X2
     PTRNME    B    0+X1
     
     ****************************************************************
     ****************************************************************
     ** CLEAN NUMBER SNIPPET                                       **
     ****************************************************************
     
     * Normalizes the zone bits of a number, leaving either A=0B=0
     * for a positive or A=0B=1 for a negative
     CLNNMN    SBR  X1
     * Do nothing on either no zone bits or only a b zone bit
               BWZ  CLNNME,0+X2,2
               BWZ  CLNNME,0+X2,K
     * else clear the zone bits, as it is positive
               MZ   @ @,0+X2
     CLNNME    B    0+X1

     ****************************************************************

     LAGAAA    DCW  @001@              * Pointer 0
     LAHAAA    DCW  @744@              * Pointer 0
     LAIAAA    DCW  @I8I@              * Pointer 0
     LBGAAA    DCW  @I9B@              * Pointer 0
     LBHAAA    DCW  @011@              * Pointer 0
     LCGAAA    DCW  @I9I@              * Pointer 0
     LDIAAA    DCW  @724@              * Pointer 0
     LEHAAA    DCW  @007@              * Pointer 0
     LFGAAA    DCW  @0@                * Value 0
     LGIAAA    DCW  @ @                * Value  
     LHHAAA    DCW  @%@                * Value %
     LHIAAA    DCW  @727@              * Pointer 0
     LIGAAA    DCW  @I8F@              * Pointer 0
     LIIAAA    DCW  @201@              * Pointer 0
     LJGAAA    DCW  @008@              * Pointer 0
     LKFAAA    DCW  @003@              * Pointer 0
     LLFAAA    DCW  @100000@           * Value 100000
     LLIAAA    DCW  @333@              * Pointer 0
     LMFAAA    DCW  @005@              * Pointer 0
     LMGAAA    DCW  @00002@            * Value 00002
     LMHAAA    DCW  @C@                * Value C
     LNFAAA    DCW  @00042@            * Value 00042
     LOFAAA    DCW  @I9E@              * Pointer 0
     LPFAAA    DCW  @00019@            * Value 00019
     LPGAAA    DCW  @00003@            * Value 00003
     LPHAAA    DCW  @S@                * Value S
     LQFAAA    DCW  @704@              * Pointer 0
     LQIAAA    DCW  @I9D@              * Pointer 0
     LRFAAA    DCW  @I9G@              * Pointer 0
     LRIAAA    DCW  @0000J@            * Value 0000J
     LSFAAA    DCW  @705@              * Pointer 0
     LSHAAA    DCW  @D@                * Value D
     LTFAAA    DCW  @00001@            * Value 00001
     LTGAAA    DCW  @00004@            * Value 00004
     LTHAAA    DCW  @00010@            * Value 00010
     LUFAAA    DCW  @014@              * Pointer 0
     LUGAAA    DCW  @736@              * Pointer 0
     LUHAAA    DCW  @012@              * Pointer 0
     LVFAAA    DCW  @006@              * Pointer 0
     LVGAAA    DCW  @00020@            * Value 00020
     LVHAAA    DCW  @I9C@              * Pointer 0
     LWFAAA    DCW  @00000@            * Value 00000
     LYGAAA    DCW  @740@              * Pointer 0
     LYHAAA    DCW  @P@                * Value P
     LZFAAA    DCW  @-@                * Value -
     LZGAAA    DCW  @20000@            * Value 20000
     LZHAAA    DCW  @010@              * Pointer 0

               END  START              * End of program code.
