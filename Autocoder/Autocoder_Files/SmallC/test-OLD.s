     ****************************************************************
     ***  test.s
     ***  Generated by Small-C Compiler on 16-Mar-2015 6:21:54 PM
     ****************************************************************
     ****************************************************************

     READ      EQU  001                * Read area
     PUNCH     EQU  101                * Punch area
     PRINT     EQU  201                * Print area
     
     PRCPOS    DCW  000                * char position in print area
     PUCPOS    DCW  000                * char position in punch area
     PUNSIZ    DCW  @080@              * Size of punch area
     PRTSIZ    DCW  @132@              * Size of print area
     EOS       DCW  @'@                * End Of String char
     EOL       DCW  @;@                * End Of Line char

               ORG  87
     X1        DSA  0                  * INDEX REGISTER 1
               ORG  92
     X2        DSA  0                  * INDEX REGISTER 2
               ORG  97
     X3        DSA  0                  * INDEX REGISTER 3
     
     * I need a single digit flag - should I replace this with a DA?
     RF        EQU  340
     
     ****************************************************************
     
     * SET THE START POSITION OF VARIABLES INITIALIZATION DATA

               ORG  600
               DCW  @69105@

               ORG  605
               DCW  @0@
               DCW  @1@
               DCW  @2@
               DCW  @3@
               DCW  @4@
               DCW  @5@
               DCW  @6@
               DCW  @7@
               DCW  @8@
               DCW  @9@
               DCW  @A@
               DCW  @B@
               DCW  @C@
               DCW  @D@
               DCW  @E@
               DCW  @F@
               DCW  @'@

               ORG  622
               DCW  @201@

               ORG  625
               DCW  @200@

               ORG  628
               DCW  @081@

               ORG  631
               DCW  @00100@

               ORG  636
               DCW  @00200@

               ORG  641
               DCW  @00000@

               ORG  646
               DCW  @649@

               ORG  649
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @'@

               ORG  661
               DCW  @664@

               ORG  664
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @A@
               DCW  @'@

               ORG  673
               DCW  @00001@

               ORG  678
               DCW  @681@

               ORG  681
               DCW  @B@
               DCW  @B@
               DCW  @B@
               DCW  @B@
               DCW  @B@
               DCW  @B@
               DCW  @B@
               DCW  @B@
               DCW  @'@

               ORG  690
               DCW  @A@
               DCW  @B@
               DCW  @C@
               DCW  @D@
               DCW  @E@
               DCW  @F@
               DCW  @G@
               DCW  @H@
               DCW  @'@

               ORG  699
               DCW  @X@
               DCW  @0@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  706
               DCW  @X@
               DCW  @1@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  713
               DCW  @X@
               DCW  @2@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  720
               DCW  @X@
               DCW  @3@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  727
               DCW  @X@
               DCW  @4@
               DCW  @:@
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  734
               DCW  @C@
               DCW  @0@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  741
               DCW  @C@
               DCW  @1@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  748
               DCW  @C@
               DCW  @2@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  755
               DCW  @C@
               DCW  @3@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  762
               DCW  @C@
               DCW  @4@
               DCW  @:@
               DCW  @%@
               DCW  @S@
               DCW  @;@
               DCW  @'@

               ORG  769
               DCW  @;@
               DCW  @D@
               DCW  @O@
               DCW  @N@
               DCW  @E@
               DCW  @.@
               DCW  @;@
               DCW  @'@

     * SET THE START POSITION OF CODE
               ORG  777
     START     NOP                     * Program starts here

     * SET THE STACK POINTER (STACK GROWS UPWARD)
               SBR  X2,399             * X2 is the stack pointer
               MCW  X2,X3              * Copy X2 to X3

               B    LNDAAA             * Jump to function main
               H                       * Program executed. System halted.

     ********************************************************************************
     * Function : puts
     ********************************************************************************
     LUBAAA    SBR  3+X3               * Save return address in register B to local frame
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LVBAAA:null]
               MA   LPDAAA,X2
     * While [while ((( *s ) != '\0')) [Block LWBAAA:LVBAAA] top:LXBAAA bottom:LYBAAA]
     LXBAAA    NOP                     * Top of the loop
     * NotEqual (!=) (( *s ) != '\0')
     * DereferenceExpression ( *s )
     * Parameter Variable (s : 15997+X3)
     * Push (15997+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  15997+X3,0+X2      * Load data at 15997+X3 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data at EOS to X2
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
               BE   LQDAAA             * Jump if equal
               B    LRDAAA             * Jump to End
     LQDAAA    MCW  LXDAAA,0+X2        * Equal: Set stack location to 0
     LRDAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LYBAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LWBAAA:LVBAAA]
     * Function Call putchar(( *(s++) ))
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * DereferenceExpression ( *(s++) )
     * PostIncrement (s++)
     * Push (LSDAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LSDAAA,0+X2        * Load data at I9G to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
               MA   LTDAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LJBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     LWBAAA    NOP                     * Return
               BCE  LVBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LWBAAA:LVBAAA]
     ***************************************

               B    LXBAAA             * Jump to top
     LYBAAA    NOP                     * Bottom of the while loop

     LVBAAA    NOP                     * Return
               MA   LSDAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LVBAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : puts
     ********************************************************************************

     ********************************************************************************
     * Function : itoa
     ********************************************************************************
     LXAAAA    SBR  3+X3               * Save return address in register B to local frame
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LYAAAA:null]
               LCA  LZDAAA,9+X3        * 605
               LCA  LVDAAA,14+X3       * 1
               MA   LAEAAA,X2
     * Assignment (start = str)
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  15992+X3,0+X2      * Load data at 15992+X3 to X2
     * Push (LBEAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data at 006 to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LSDAAA,X2          * Add -3 to X2
     * If [if ((value < 0) then [Block LZAAAA:LYAAAA] else [if ((value == 0) then [Block LABAAA:LYAAAA]]]
     * Less (<) (value < 0)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data at 15997+X3 to X2
               B    LCEAAA             * Jump to snippet clean_number
     * Constant (0 : LXDAAA)
     * Push (LXDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data at 00000 to X2
               B    LCEAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2      * Compare
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               MCW  LXDAAA,0+X2        * Set stack location to 0
               BL   LEEAAA             * Jump if less
               B    LFEAAA             * Jump to End
     LEEAAA    MCW  LVDAAA,0+X2        * Less: Set stack location to 1
     LFEAAA    NOP                     * End of Less
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LCBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LZAAAA:LYAAAA]
     * Assignment (( *(str++) ) = '-')
     * Constant ('-' : @-@)
     * Push (@-@:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  @-@,0+X2           * Load data at - to X2
     * PostIncrement (str++)
     * Push (LHEAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LHEAAA,0+X2        * Load data at I9B to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
               MA   LTDAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LUDAAA,X2          * Add -1 to X2
     * Assignment (value = (-value))
     * Negate (-value)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data at 15997+X3 to X2
               ZS   0+X2
               B    LCEAAA             * Jump to snippet clean_number
     * Push (LSDAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LSDAAA,0+X2        * Load data at I9G to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LYDAAA,X2          * Add -5 to X2
     LZAAAA    NOP                     * Return
               BCE  LYAAAA,RF,R        * Jump back to caller
     * EndBlock [Block LZAAAA:LYAAAA]
     ***************************************

               B    LDBAAA             * Jump when true
     LCBAAA    NOP                     * Executed when False
     * If [if ((value == 0) then [Block LABAAA:LYAAAA]]
     * Equal (==) (value == 0)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data at 15997+X3 to X2
               B    LCEAAA             * Jump to snippet clean_number
     * Constant (0 : LXDAAA)
     * Push (LXDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data at 00000 to X2
               B    LCEAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2      * Compare
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Push (LXDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data at 00000 to X2
               BE   LIEAAA             * Jump if equal
               B    LJEAAA             * Jump to End
     LIEAAA    MCW  LVDAAA,0+X2        * Equal
     LJEAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LBBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LABAAA:LYAAAA]
     * Assignment ((str[0]) = '0')
     * Constant ('0' : @0@)
     * Push (@0@:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  @0@,0+X2           * Load data at 0 to X2
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  15992+X3,0+X2      * Load data at 15992+X3 to X2
     * Constant (0 : LXDAAA)
     * Push (LXDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data at 00000 to X2
     * raw index on the stack
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * STACK top is location in array now.
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LUDAAA,X2          * Add -1 to X2
     * Assignment ((str[1]) = '\0')
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data at EOS to X2
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  15992+X3,0+X2      * Load data at 15992+X3 to X2
     * Constant (1 : LVDAAA)
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
     * raw index on the stack
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * STACK top is location in array now.
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LUDAAA,X2          * Add -1 to X2
     * Local Variable (start : 6+X3)
     * Push (6+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data at 6+X3 to X2
     * Pop (15984+X3:3)
               LCA  0+X2,15984+X3      * Load data at X2 to 15984+X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF             * PUT R into location RF
               B    LABAAA             * Jump back to caller
     LABAAA    NOP                     * Return
               BCE  LYAAAA,RF,R        * Jump back to caller
     * EndBlock [Block LABAAA:LYAAAA]
     ***************************************

     LBBAAA    NOP                     * Executed when False
     LDBAAA    NOP                     * Executed when True
     * While [while ((exp <= (value / base))) (exp = (exp * base)) top:LEBAAA bottom:LFBAAA]
     LEBAAA    NOP                     * Top of the loop
     * LessOrEqual (<=) (exp <= (value / base))
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data at 14+X3 to X2
               B    LCEAAA             * Jump to snippet clean_number
     * Divide (value / base)
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  15989+X3,0+X2      * Load data at 15989+X3 to X2
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data at 15997+X3 to X2
               B    LSEAAA             * Jump to snippet SNIP_DIV
               MCW  0+X2,15995+X2      * copy stack location to stack location at offset -5
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               B    LCEAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2      * Compare
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               MCW  LVDAAA,0+X2        * Set stack location to 1
               BH   LYEAAA             * Jump if less or equal
               B    LZEAAA             * Jump to End
     LYEAAA    MCW  LXDAAA,0+X2        * Less or equal: Set stack location to 0
     LZEAAA    NOP                     * End of LessOrEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LFBAAA,5+X2,       * Jump to bottom
     * Assignment (exp = (exp * base))
     * Multiply (exp * base)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data at 14+X3 to X2
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  15989+X3,0+X2      * Load data at 15989+X3 to X2
               M    15995+X2,6+X2      * Multiply
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Push (LAEAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LAEAAA,0+X2        * Load data at 014 to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LYDAAA,X2          * Add -5 to X2
               B    LEBAAA             * Jump to top
     LFBAAA    NOP                     * Bottom of the while loop

     * While [while (exp) [Block LGBAAA:LYAAAA] top:LHBAAA bottom:LIBAAA]
     LHBAAA    NOP                     * Top of the loop
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data at 14+X3 to X2
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LIBAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LGBAAA:LYAAAA]
     * Assignment (( *(str++) ) = (digits[(value / exp)]))
     * SubScript (digits[(value / exp)])
     * Local Variable (digits : 9+X3)
     * Push (9+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  9+X3,0+X2          * Load data at 9+X3 to X2
     * Divide (value / exp)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data at 14+X3 to X2
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data at 15997+X3 to X2
               B    LSEAAA             * Jump to snippet SNIP_DIV
               MCW  0+X2,15995+X2      * copy stack location to stack location at offset -5
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * raw index on the stack
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * STACK top is location in array now.
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * PostIncrement (str++)
     * Push (LHEAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LHEAAA,0+X2        * Load data at I9B to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
               MA   LTDAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LUDAAA,X2          * Add -1 to X2
     * Assignment (value = (value % exp))
     * Modulo (%) (value % exp)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data at 14+X3 to X2
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  15997+X3,0+X2      * Load data at 15997+X3 to X2
               B    LSEAAA             * Jump to snippet SNIP_DIV
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Push (LSDAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LSDAAA,0+X2        * Load data at I9G to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LYDAAA,X2          * Add -5 to X2
     * Assignment (exp = (exp / base))
     * Divide (exp / base)
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  15989+X3,0+X2      * Load data at 15989+X3 to X2
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  14+X3,0+X2         * Load data at 14+X3 to X2
               B    LSEAAA             * Jump to snippet SNIP_DIV
               MCW  0+X2,15995+X2      * copy stack location to stack location at offset -5
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Push (LAEAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LAEAAA,0+X2        * Load data at 014 to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LYDAAA,X2          * Add -5 to X2
     LGBAAA    NOP                     * Return
               BCE  LYAAAA,RF,R        * Jump back to caller
     * EndBlock [Block LGBAAA:LYAAAA]
     ***************************************

               B    LHBAAA             * Jump to top
     LIBAAA    NOP                     * Bottom of the while loop

     * Assignment (( *str ) = '\0')
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data at EOS to X2
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  15992+X3,0+X2      * Load data at 15992+X3 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LUDAAA,X2          * Add -1 to X2
     * Local Variable (start : 6+X3)
     * Push (6+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data at 6+X3 to X2
     * Pop (15984+X3:3)
               LCA  0+X2,15984+X3      * Load data at X2 to 15984+X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF             * PUT R into location RF
               B    LYAAAA             * Jump back to caller
     LYAAAA    NOP                     * Return
               MA   LAFAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LYAAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : itoa
     ********************************************************************************

     ********************************************************************************
     * Function : strlen
     ********************************************************************************
     LFAAAA    SBR  3+X3               * Save return address in register B to local frame
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LGAAAA:null]
               LCA  LBFAAA,8+X3        * -1
               MA   LCFAAA,X2
     * While [while (((str[(++len)]) != '\0')) [] top:LHAAAA bottom:LIAAAA]
     LHAAAA    NOP                     * Top of the loop
     * NotEqual (!=) ((str[(++len)]) != '\0')
     * SubScript (str[(++len)])
     * Parameter Variable (str : 15997+X3)
     * Push (15997+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  15997+X3,0+X2      * Load data at 15997+X3 to X2
     * PreIncrement((++len)
     * Push (LCFAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LCFAAA,0+X2        * Load data at 008 to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
               A    LVDAAA,0+X1        * PreIncrement variable pointed by X1
     * Push (0+X1:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * raw index on the stack
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLEAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * STACK top is location in array now.
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data at EOS to X2
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
               BE   LDFAAA             * Jump if equal
               B    LEFAAA             * Jump to End
     LDFAAA    MCW  LXDAAA,0+X2        * Equal: Set stack location to 0
     LEFAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LIAAAA,5+X2,       * Jump to bottom
               B    LHAAAA             * Jump to top
     LIAAAA    NOP                     * Bottom of the while loop

     * Local Variable (len : 8+X3)
     * Push (8+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  8+X3,0+X2          * Load data at 8+X3 to X2
     * Pop (15994+X3:5)
               LCA  0+X2,15994+X3      * Load data at X2 to 15994+X3
               MA   LYDAAA,X2          * Add -5 to X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF             * PUT R into location RF
               B    LGAAAA             * Jump back to caller
     LGAAAA    NOP                     * Return
               MA   LHEAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LGAAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : strlen
     ********************************************************************************

     ********************************************************************************
     * Function : genRand
     ********************************************************************************
     LBAAAA    SBR  3+X3               * Save return address in register B to local frame
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LCAAAA:null]
               MA   LPDAAA,X2
     * Assignment (seed = (((42 * seed) + 19) % 100000))
     * Modulo (%) (((42 * seed) + 19) % 100000)
     * Constant (100000 : LFFAAA)
     * Push (LFFAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LFFAAA,0+X2        * Load data at 100000 to X2
     * Addition ((42 * seed) + 19)
     * Multiply (42 * seed)
     * Constant (42 : LGFAAA)
     * Push (LGFAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LGFAAA,0+X2        * Load data at 00042 to X2
     * Static Variable (seed : 604)
     * Push (604:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  604,0+X2           * Load data at 604 to X2
               M    15995+X2,6+X2      * Multiply
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Constant (19 : LHFAAA)
     * Push (LHFAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LHFAAA,0+X2        * Load data at 00019 to X2
               A    0+X2,15995+X2      * Add
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               B    LSEAAA             * Jump to snippet SNIP_DIV
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Push (LIFAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LIFAAA,0+X2        * Load data at 604 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LYDAAA,X2          * Add -5 to X2
     * Static Variable (seed : 604)
     * Push (604:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  604,0+X2           * Load data at 604 to X2
     * Pop (15997+X3:5)
               LCA  0+X2,15997+X3      * Load data at X2 to 15997+X3
               MA   LYDAAA,X2          * Add -5 to X2
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF             * PUT R into location RF
               B    LCAAAA             * Jump back to caller
     LCAAAA    NOP                     * Return
               MA   LSDAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LCAAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : genRand
     ********************************************************************************

     ********************************************************************************
     * Function : strcpy
     ********************************************************************************
     LJAAAA    SBR  3+X3               * Save return address in register B to local frame
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LKAAAA:null]
               MA   LPDAAA,X2
     * While [while (((( *(dest++) ) = ( *(src++) )) != '\0')) [] top:LLAAAA bottom:LMAAAA]
     LLAAAA    NOP                     * Top of the loop
     * NotEqual (!=) ((( *(dest++) ) = ( *(src++) )) != '\0')
     * Assignment (( *(dest++) ) = ( *(src++) ))
     * DereferenceExpression ( *(src++) )
     * PostIncrement (src++)
     * Push (LLFAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LLFAAA,0+X2        * Load data at I9D to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
               MA   LTDAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * PostIncrement (dest++)
     * Push (LSDAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LSDAAA,0+X2        * Load data at I9G to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
               MA   LTDAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
               LCA  0+X2,0+X1          * Load data at Stack location to X1
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data at EOS to X2
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
               BE   LJFAAA             * Jump if equal
               B    LKFAAA             * Jump to End
     LJFAAA    MCW  LXDAAA,0+X2        * Equal: Set stack location to 0
     LKFAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LMAAAA,5+X2,       * Jump to bottom
               B    LLAAAA             * Jump to top
     LMAAAA    NOP                     * Bottom of the while loop

     LKAAAA    NOP                     * Return
               MA   LSDAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LKAAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : strcpy
     ********************************************************************************

     ********************************************************************************
     * Function : putchar
     ********************************************************************************
     LJBAAA    SBR  3+X3               * Save return address in register B to local frame
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LKBAAA:null]
               MA   LPDAAA,X2
     * If [if ((c != '\n') then [Block LLBAAA:LKBAAA] else [Block LMBAAA:LKBAAA]]
     * NotEqual (!=) (c != '\n')
     * Parameter Variable (c : 15997+X3)
     * Push (15997+X3:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  15997+X3,0+X2      * Load data at 15997+X3 to X2
     * Constant ('\n' : EOL)
     * Push (EOL:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  EOL,0+X2           * Load data at EOL to X2
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
               BE   LMFAAA             * Jump if equal
               B    LNFAAA             * Jump to End
     LMFAAA    MCW  LXDAAA,0+X2        * Equal: Set stack location to 0
     LNFAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LQBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LLBAAA:LKBAAA]
     * Assignment (( *(__putchar_pos++) ) = c)
     * Parameter Variable (c : 15997+X3)
     * Push (15997+X3:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  15997+X3,0+X2      * Load data at 15997+X3 to X2
     * PostIncrement (__putchar_pos++)
     * Push (LOFAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LOFAAA,0+X2        * Load data at 624 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
               MA   LTDAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LUDAAA,X2          * Add -1 to X2
     LLBAAA    NOP                     * Return
               BCE  LKBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LLBAAA:LKBAAA]
     ***************************************

               B    LRBAAA             * Jump when true
     LQBAAA    NOP                     * Executed when False

     ***************************************
     * BeginBlock [Block LMBAAA:LKBAAA]
     * While [while ((((int) __putchar_last) >= ((int) __putchar_pos))) [Block LNBAAA:LMBAAA] top:LOBAAA bottom:LPBAAA]
     LOBAAA    NOP                     * Top of the loop
     * GreaterOrEqual (>=) ((((int) __putchar_last) >= ((int) __putchar_pos))
     * Static Variable (__putchar_last : 627)
     * Push (627:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  627,0+X2           * Load data at 627 to X2
     * Cast Pointer(__putchar_last) to Number
               B    LPFAAA             * Jump to snippet pointer_to_number
               B    LCEAAA             * Jump to snippet clean_number
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  624,0+X2           * Load data at 624 to X2
     * Cast Pointer(__putchar_pos) to Number
               B    LPFAAA             * Jump to snippet pointer_to_number
               B    LCEAAA             * Jump to snippet clean_number
               C    0+X2,15995+X2      * Compare
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               MCW  LVDAAA,0+X2        * Set stack location to 1
               BL   LYFAAA             * Jump if greater or equal
               B    LZFAAA             * Jump to End
     LYFAAA    MCW  LXDAAA,0+X2        * GreaterOrEqual: Set stack location to 0
     LZFAAA    NOP                     * End of GreaterOrEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LPBAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LNBAAA:LMBAAA]
     * Assignment (( *(__putchar_last--) ) = ' ')
     * Constant (' ' : @ @)
     * Push (@ @:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  @ @,0+X2           * Load data at   to X2
     * PostDecrement (__putchar_last--)
     * Push (LBGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LBGAAA,0+X2        * Load data at 627 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
               MA   LUDAAA,0+X1        * PostDecrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LUDAAA,X2          * Add -1 to X2
     LNBAAA    NOP                     * Return
               BCE  LMBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LNBAAA:LMBAAA]
     ***************************************

               B    LOBAAA             * Jump to top
     LPBAAA    NOP                     * Bottom of the while loop

     * Assignment (__putchar_last = __putchar_pos)
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  624,0+X2           * Load data at 624 to X2
     * Push (LBGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LBGAAA,0+X2        * Load data at 627 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Assignment (__putchar_pos = 201)
     * Constant (201 : LCGAAA)
     * Push (LCGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LCGAAA,0+X2        * Load data at 201 to X2
     * Push (LOFAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LOFAAA,0+X2        * Load data at 624 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Start asm block
               W    
     * End asm block
     LMBAAA    NOP                     * Return
               BCE  LKBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LMBAAA:LKBAAA]
     ***************************************

     LRBAAA    NOP                     * Executed when True
     * If [if ((__putchar_pos == 333) then [Block LSBAAA:LKBAAA]]
     * Equal (==) (__putchar_pos == 333)
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  624,0+X2           * Load data at 624 to X2
     * Constant (333 : LFGAAA)
     * Push (LFGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LFGAAA,0+X2        * Load data at 333 to X2
               C    0+X2,15997+X2      * Compare
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (LXDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data at 00000 to X2
               BE   LDGAAA             * Jump if equal
               B    LEGAAA             * Jump to End
     LDGAAA    MCW  LVDAAA,0+X2        * Equal
     LEGAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LTBAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LSBAAA:LKBAAA]
     * Assignment (__putchar_last = __putchar_pos)
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  624,0+X2           * Load data at 624 to X2
     * Push (LBGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LBGAAA,0+X2        * Load data at 627 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Assignment (__putchar_pos = 201)
     * Constant (201 : LCGAAA)
     * Push (LCGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LCGAAA,0+X2        * Load data at 201 to X2
     * Push (LOFAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LOFAAA,0+X2        * Load data at 624 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Start asm block
               W    
     * End asm block
     LSBAAA    NOP                     * Return
               BCE  LKBAAA,RF,R        * Jump back to caller
     * EndBlock [Block LSBAAA:LKBAAA]
     ***************************************

     LTBAAA    NOP                     * Executed when False
     LKBAAA    NOP                     * Return
               MA   LSDAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LKBAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : putchar
     ********************************************************************************

     ********************************************************************************
     * Function : main
     ********************************************************************************
     LNDAAA    SBR  3+X3               * Save return address in register B to local frame
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LODAAA:null]
               LCA  LGGAAA,8+X3        * 100
               LCA  LHGAAA,11+X3       * 690
               MA   LIGAAA,X2
     * Assignment (x3 = (x0 + x1))
     * Addition (x0 + x1)
     * Static Variable (x0 : 635)
     * Push (635:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  635,0+X2           * Load data at 635 to X2
     * Static Variable (x1 : 640)
     * Push (640:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  640,0+X2           * Load data at 640 to X2
               A    0+X2,15995+X2      * Add
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Push (LJGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LJGAAA,0+X2        * Load data at 645 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LYDAAA,X2          * Add -5 to X2
     * Assignment (c1 = c0)
     * Static Variable (c0 : 648)
     * Push (648:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  648,0+X2           * Load data at 648 to X2
     * Push (LKGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LKGAAA,0+X2        * Load data at 660 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Assignment (c1 = c4)
     * Local Variable (c4 : 11+X3)
     * Push (11+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  11+X3,0+X2         * Load data at 11+X3 to X2
     * Push (LKGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LKGAAA,0+X2        * Load data at 660 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Assignment (x3 = x4)
     * Local Variable (x4 : 8+X3)
     * Push (8+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  8+X3,0+X2          * Load data at 8+X3 to X2
     * Push (LJGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LJGAAA,0+X2        * Load data at 645 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_9, x0)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Static Variable (x0 : 635)
     * Push (635:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  635,0+X2           * Load data at 635 to X2
     * Static Array (STR_LIT_9:char [7])
     * Push (LLGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LLGAAA,0+X2        * Load data at 699 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_10, x1)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Static Variable (x1 : 640)
     * Push (640:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  640,0+X2           * Load data at 640 to X2
     * Static Array (STR_LIT_10:char [7])
     * Push (LMGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LMGAAA,0+X2        * Load data at 706 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_11, x2)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Static Variable (x2 : 677)
     * Push (677:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  677,0+X2           * Load data at 677 to X2
     * Static Array (STR_LIT_11:char [7])
     * Push (LNGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LNGAAA,0+X2        * Load data at 713 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_12, x3)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Static Variable (x3 : 645)
     * Push (645:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  645,0+X2           * Load data at 645 to X2
     * Static Array (STR_LIT_12:char [7])
     * Push (LOGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LOGAAA,0+X2        * Load data at 720 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_13, x4)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Local Variable (x4 : 8+X3)
     * Push (8+X3:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  8+X3,0+X2          * Load data at 8+X3 to X2
     * Static Array (STR_LIT_13:char [7])
     * Push (LPGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LPGAAA,0+X2        * Load data at 727 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_14, c0)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Static Variable (c0 : 648)
     * Push (648:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  648,0+X2           * Load data at 648 to X2
     * Static Array (STR_LIT_14:char [7])
     * Push (LQGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LQGAAA,0+X2        * Load data at 734 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_15, c1)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Static Variable (c1 : 660)
     * Push (660:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  660,0+X2           * Load data at 660 to X2
     * Static Array (STR_LIT_15:char [7])
     * Push (LRGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LRGAAA,0+X2        * Load data at 741 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_16, c2)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Static Variable (c2 : 663)
     * Push (663:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  663,0+X2           * Load data at 663 to X2
     * Static Array (STR_LIT_16:char [7])
     * Push (LSGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LSGAAA,0+X2        * Load data at 748 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_17, c3)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Static Variable (c3 : 680)
     * Push (680:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  680,0+X2           * Load data at 680 to X2
     * Static Array (STR_LIT_17:char [7])
     * Push (LTGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LTGAAA,0+X2        * Load data at 755 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_18, c4)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Local Variable (c4 : 11+X3)
     * Push (11+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  11+X3,0+X2         * Load data at 11+X3 to X2
     * Static Array (STR_LIT_18:char [7])
     * Push (LUGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LUGAAA,0+X2        * Load data at 762 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Function Call printf(STR_LIT_19)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Static Array (STR_LIT_19:char [8])
     * Push (LVGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LVGAAA,0+X2        * Load data at 769 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LNCAAA             * Jump to function printf
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     LODAAA    NOP                     * Return
               MA   LWGAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LODAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : main
     ********************************************************************************

     ********************************************************************************
     * Function : printf
     ********************************************************************************
     LNCAAA    SBR  3+X3               * Save return address in register B to local frame
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LOCAAA:null]
               MA   LXGAAA,X2
     * Assignment (arg = ((*char) (( &cformat_str ) + 15997)))
     * Addition (( &cformat_str ) + 15997)
     * AddressOf ( &cformat_str )
     * Push (LSDAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LSDAAA,0+X2        * Load data at I9G to X2
               MA   X3,0+X2
     * Constant (15997 : LSDAAA)
     * Push (LSDAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LSDAAA,0+X2        * Load data at I9G to X2
               MA   0+X2,15997+X2      * Add
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (LBEAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data at 006 to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LSDAAA,X2          * Add -3 to X2
     * While [while (((c = ( *(cformat_str++) )) != '\0')) [Block LPCAAA:LOCAAA] top:LHDAAA bottom:LIDAAA]
     LHDAAA    NOP                     * Top of the loop
     * NotEqual (!=) ((c = ( *(cformat_str++) )) != '\0')
     * Assignment (c = ( *(cformat_str++) ))
     * DereferenceExpression ( *(cformat_str++) )
     * PostIncrement (cformat_str++)
     * Push (LSDAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LSDAAA,0+X2        * Load data at I9G to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
               MA   LTDAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * Push (LXGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LXGAAA,0+X2        * Load data at 007 to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
               LCA  0+X2,0+X1          * Load data at Stack location to X1
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  EOS,0+X2           * Load data at EOS to X2
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
               BE   LYGAAA             * Jump if equal
               B    LZGAAA             * Jump to End
     LYGAAA    MCW  LXDAAA,0+X2        * Equal: Set stack location to 0
     LZGAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LIDAAA,5+X2,       * Jump to bottom

     ***************************************
     * BeginBlock [Block LPCAAA:LOCAAA]
     * If [if ((c != '%') then [Block LQCAAA:LPCAAA] else [Block LRCAAA:LPCAAA]]
     * NotEqual (!=) (c != '%')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data at 7+X3 to X2
     * Constant ('%' : @%@)
     * Push (@%@:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  @%@,0+X2           * Load data at % to X2
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Push (LVDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LVDAAA,0+X2        * Load data at 00001 to X2
               BE   LAHAAA             * Jump if equal
               B    LBHAAA             * Jump to End
     LAHAAA    MCW  LXDAAA,0+X2        * Equal: Set stack location to 0
     LBHAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LFDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LQCAAA:LPCAAA]
     * Function Call putchar(c)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data at 7+X3 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LJBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     LQCAAA    NOP                     * Return
               BCE  LPCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LQCAAA:LPCAAA]
     ***************************************

               B    LGDAAA             * Jump when true
     LFDAAA    NOP                     * Executed when False

     ***************************************
     * BeginBlock [Block LRCAAA:LPCAAA]
     * Assignment (c = ( *(cformat_str++) ))
     * DereferenceExpression ( *(cformat_str++) )
     * PostIncrement (cformat_str++)
     * Push (LSDAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LSDAAA,0+X2        * Load data at I9G to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
               MA   LTDAAA,0+X1        * PostIncrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * Push (LXGAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LXGAAA,0+X2        * Load data at 007 to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LUDAAA,X2          * Add -1 to X2
     * If [if ((c == '%') then [Block LSCAAA:LRCAAA] else [if ((c == 'C') then [Block LTCAAA:LRCAAA] else [if ((c == 'S') then [Block LUCAAA:LRCAAA] else [if ((c == 'D') then [Block LVCAAA:LRCAAA] else [Block LWCAAA:LRCAAA]]]]]
     * Equal (==) (c == '%')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data at 7+X3 to X2
     * Constant ('%' : @%@)
     * Push (@%@:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  @%@,0+X2           * Load data at % to X2
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Push (LXDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data at 00000 to X2
               BE   LDHAAA             * Jump if equal
               B    LEHAAA             * Jump to End
     LDHAAA    MCW  LVDAAA,0+X2        * Equal
     LEHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LDDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LSCAAA:LRCAAA]
     * Function Call putchar('%')
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Constant ('%' : @%@)
     * Push (@%@:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  @%@,0+X2           * Load data at % to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LJBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     LSCAAA    NOP                     * Return
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LSCAAA:LRCAAA]
     ***************************************

               B    LEDAAA             * Jump when true
     LDDAAA    NOP                     * Executed when False
     * If [if ((c == 'C') then [Block LTCAAA:LRCAAA] else [if ((c == 'S') then [Block LUCAAA:LRCAAA] else [if ((c == 'D') then [Block LVCAAA:LRCAAA] else [Block LWCAAA:LRCAAA]]]]
     * Equal (==) (c == 'C')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data at 7+X3 to X2
     * Constant ('C' : @C@)
     * Push (@C@:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  @C@,0+X2           * Load data at C to X2
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Push (LXDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data at 00000 to X2
               BE   LFHAAA             * Jump if equal
               B    LGHAAA             * Jump to End
     LFHAAA    MCW  LVDAAA,0+X2        * Equal
     LGHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LBDAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LTCAAA:LRCAAA]
     * Function Call putchar(( *(arg--) ))
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * DereferenceExpression ( *(arg--) )
     * PostDecrement (arg--)
     * Push (LBEAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data at 006 to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
               MA   LUDAAA,0+X1        * PostDecrement pointer pointed by X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LJBAAA             * Jump to function putchar
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     LTCAAA    NOP                     * Return
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LTCAAA:LRCAAA]
     ***************************************

               B    LCDAAA             * Jump when true
     LBDAAA    NOP                     * Executed when False
     * If [if ((c == 'S') then [Block LUCAAA:LRCAAA] else [if ((c == 'D') then [Block LVCAAA:LRCAAA] else [Block LWCAAA:LRCAAA]]]
     * Equal (==) (c == 'S')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data at 7+X3 to X2
     * Constant ('S' : @S@)
     * Push (@S@:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  @S@,0+X2           * Load data at S to X2
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Push (LXDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data at 00000 to X2
               BE   LIHAAA             * Jump if equal
               B    LJHAAA             * Jump to End
     LIHAAA    MCW  LVDAAA,0+X2        * Equal
     LJHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LZCAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LUCAAA:LRCAAA]
     * Function Call puts(( *((**char) arg) ))
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * DereferenceExpression ( *((**char) arg) )
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data at 6+X3 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LUBAAA             * Jump to function puts
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Assignment (arg = (arg + 15997))
     * Addition (arg + 15997)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data at 6+X3 to X2
     * Constant (15997 : LSDAAA)
     * Push (LSDAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LSDAAA,0+X2        * Load data at I9G to X2
               MA   0+X2,15997+X2      * Add
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (LBEAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data at 006 to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LSDAAA,X2          * Add -3 to X2
     LUCAAA    NOP                     * Return
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LUCAAA:LRCAAA]
     ***************************************

               B    LADAAA             * Jump when true
     LZCAAA    NOP                     * Executed when False
     * If [if ((c == 'D') then [Block LVCAAA:LRCAAA] else [Block LWCAAA:LRCAAA]]
     * Equal (==) (c == 'D')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  7+X3,0+X2          * Load data at 7+X3 to X2
     * Constant ('D' : @D@)
     * Push (@D@:1)
               MA   LTDAAA,X2          * Add 1 to X2
               LCA  @D@,0+X2           * Load data at D to X2
               C    0+X2,15999+X2      * Compare
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Pop (1)
               MA   LUDAAA,X2          * Add -1 to X2
     * Push (LXDAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LXDAAA,0+X2        * Load data at 00000 to X2
               BE   LLHAAA             * Jump if equal
               B    LMHAAA             * Jump to End
     LLHAAA    MCW  LVDAAA,0+X2        * Equal
     LMHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
               BCE  LXCAAA,5+X2,       * Jump when False

     ***************************************
     * BeginBlock [Block LVCAAA:LRCAAA]
               MA   LXGAAA,X2
     * Function Call itoa(( *((*int) arg) ), a, 10)
     * Push (3)
               MA   LPDAAA,X2          * Add 3 to X2
     * Constant (10 : LOHAAA)
     * Push (LOHAAA:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  LOHAAA,0+X2        * Load data at 00010 to X2
     * Local Array (a:char [7])
     * Push (LCFAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LCFAAA,0+X2        * Load data at 008 to X2
               MA   X3,0+X2
     * DereferenceExpression ( *((*int) arg) )
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data at 6+X3 to X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (0+X1:5)
               MA   LWDAAA,X2          * Add 5 to X2
               LCA  0+X1,0+X2          * Load data at 0+X1 to X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LXAAAA             * Jump to function itoa
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Function Call puts(a)
     * Push (5)
               MA   LWDAAA,X2          * Add 5 to X2
     * Local Array (a:char [7])
     * Push (LCFAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LCFAAA,0+X2        * Load data at 008 to X2
               MA   X3,0+X2
     * Push (X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  X3,0+X2            * Load data at X3 to X2
               MCW  X2,X3              * Copy X2 into X3
               B    LUBAAA             * Jump to function puts
     * Pop (X3:3)
               LCA  0+X2,X3            * Load data at X2 to X3
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (5)
               MA   LYDAAA,X2          * Add -5 to X2
     * Assignment (arg = (arg + 15995))
     * Addition (arg + 15995)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  6+X3,0+X2          * Load data at 6+X3 to X2
     * Constant (15995 : LYDAAA)
     * Push (LYDAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LYDAAA,0+X2        * Load data at I9E to X2
               MA   0+X2,15997+X2      * Add
     * Pop (3)
               MA   LSDAAA,X2          * Add -3 to X2
     * Push (LBEAAA:3)
               MA   LPDAAA,X2          * Add 3 to X2
               LCA  LBEAAA,0+X2        * Load data at 006 to X2
               MA   X3,0+X2
     * Pop (X1:3)
               LCA  0+X2,X1            * Load data at X2 to X1
               MA   LSDAAA,X2          * Add -3 to X2
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load data at X2 to 0+X1
               MA   LSDAAA,X2          * Add -3 to X2
     LVCAAA    NOP                     * Return
               MA   LPHAAA,X2
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LVCAAA:LRCAAA]
     ***************************************

               B    LYCAAA             * Jump when true
     LXCAAA    NOP                     * Executed when False

     ***************************************
     * BeginBlock [Block LWCAAA:LRCAAA]
     * Set the return flag, so we know do deallocate our stack
               MCW  @R@,RF             * PUT R into location RF
               B    LWCAAA             * Jump back to caller
     LWCAAA    NOP                     * Return
               BCE  LRCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LWCAAA:LRCAAA]
     ***************************************

     LYCAAA    NOP                     * Executed when True
     LADAAA    NOP                     * Executed when True
     LCDAAA    NOP                     * Executed when True
     LEDAAA    NOP                     * Executed when True
     LRCAAA    NOP                     * Return
               BCE  LPCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LRCAAA:LPCAAA]
     ***************************************

     LGDAAA    NOP                     * Executed when True
     LPCAAA    NOP                     * Return
               BCE  LOCAAA,RF,R        * Jump back to caller
     * EndBlock [Block LPCAAA:LOCAAA]
     ***************************************

               B    LHDAAA             * Jump to top
     LIDAAA    NOP                     * Bottom of the while loop

     LOCAAA    NOP                     * Return
               MA   LPHAAA,X2
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LOCAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : printf
     ********************************************************************************
     LCEAAA    SBR  X1
     * Normalizes the zone bits of a number, leaving either A=0B=0
     * for a positive or A=0B=1 for a negative
     * Do nothing on either no zone bits or only a b zone bit
               BWZ  LDEAAA,0+X2,2
               BWZ  LDEAAA,0+X2,K
     * else clear the zone bits, as it is positive
               MZ   @ @,0+X2
     LDEAAA    B    0+X1
     ****************************************************************  
     ** DIVISION SNIPPET                                           **
     ****************************************************************  
     
     LSEAAA    SBR  LTEAAA+3           * SETUP RETURN ADDRESS
     * POP DIVIDEND
               MCW  0+X2, LUEAAA
               SBR  X2, 15995+X2

     * POP DIVISOR
               MCW  0+X2, LVEAAA
               SBR  X2, 15995+X2

               B    *+17
               
               DCW  @00000@                
               DC   @00000000000@        

               ZA   LUEAAA, *-7         * PUT DIVIDEND INTO WORKING BL
               D    LVEAAA, *-19        * DIVIDE
               MZ   *-22, *-21          * KILL THE ZONE BIT
               MZ   *-29, *-34          * KILL THE ZONE BIT
               MCW  *-41, LWEAAA        * PICK UP ANSWER
               SW   *-44                * SO I CAN PICKUP REMAINDER
               MCW  *-46, LXEAAA        * GET REMAINDER
               CW   *-55                * CLEAR THE WM
               MZ   LWEAAA-1, LWEAAA    * CLEANUP QUOTIENT BITZONE
               MZ   LXEAAA-1, LXEAAA    * CLEANUP REMAINDER BITZONE
               
     * PUSH REMAINDER
               SBR  X2, 5+X2
               SW   15996+X2
               MCW  LXEAAA, 0+X2
               
     * PUSH QUOTIENT
               SBR  X2, 5+X2
               SW   15996+X2
               MCW  LWEAAA, 0+X2

     LTEAAA    B    000                 * JUMP BACK
               
     LVEAAA    DCW  00000               * DIVISOR
     LUEAAA    DCW  00000               * DIVIDEND
     LWEAAA    DCW  00000               * QUOTIENT
     LXEAAA    DCW  00000               * REMAINDER

     ****************************************************************
 
     ****************************************************************
     ** CAST NUMBER TO POINTER SNIPPET                             **
     ****************************************************************
     LLEAAA    SBR  X1
     * Casts a 5-digit number to a 3-digit address
     * make a copy of the top of the stack
               SW   15998+X2
               LCA  0+X2,3+X2
               CW   15998+X2
     * zero out the zone bits of our copy
               MZ   @0@,3+X2
               MZ   @0@,2+X2
               MZ   @0@,1+X2
     * set the low-order digit's zone bits
               C    @04000@,0+X2
               BL   LOEAAA
               C    @08000@,0+X2
               BL   LNEAAA
               C    @12000@,0+X2
               BL   LMEAAA
               S    @12000@,0+X2
               MZ   @A@,3+X2
               B    LOEAAA
     LMEAAA    S    @08000@,0+X2
               MZ   @I@,3+X2
               B    LOEAAA
     LNEAAA    S    @04000@,0+X2
               MZ   @S@,3+X2
     * For some reason the zone bits get set - it still works though.
     LOEAAA    C    @01000@,0+X2
               BL   LREAAA
               C    @02000@,0+X2
               BL   LQEAAA
               C    @03000@,0+X2
               BL   LPEAAA
               MZ   @A@,1+X2
               B    LREAAA
     LPEAAA    MZ   @I@,1+X2
               B    LREAAA
     LQEAAA    MZ   @S@,1+X2
     LREAAA    LCA  3+X2,15998+X2
               SBR  X2,15998+X2
               B    0+X1
               
     ****************************************************************
     
     ****************************************************************
     ** CAST POINTER TO NUMBER SNIPPET                             **
     ****************************************************************
     LPFAAA    SBR  X1
     * Casts a 3-digit address to a 5-digit number
     * Make room on the stack for an int
               MA   @002@,X2
     * make a copy of the top of the stack
               LCA  15998+X2,3+X2
     * Now zero out the top of the stack
               LCA  @00000@,0+X2
     * Now copy back, shifted over 2 digits
               MCW  3+X2,0+X2
     * Now zero out the zone bits on the stack
               MZ   @0@,0+X2
               MZ   @0@,15999+X2
               MZ   @0@,15998+X2
     * check the high-order digit's zone bits
               BWZ  LQFAAA,1+X2,S
               BWZ  LRFAAA,1+X2,K
               BWZ  LSFAAA,1+X2,B
               B    LTFAAA
     LQFAAA    A    @01000@,0+X2
               B    LTFAAA
     LRFAAA    A    @02000@,0+X2
               B    LTFAAA
     LSFAAA    A    @03000@,0+X2
     LTFAAA    BWZ  LUFAAA,3+X2,S
               BWZ  LVFAAA,3+X2,K
               BWZ  LWFAAA,3+X2,B
               B    LXFAAA
     LUFAAA    A    @04000@,0+X2
               B    LXFAAA
     LVFAAA    A    @08000@,0+X2
               B    LXFAAA
     LWFAAA    A    @12000@,0+X2
     LXFAAA    B    0+X1

     ****************************************************************

     LMGAAA    DCW  @706@              * Pointer 706
     LJGAAA    DCW  @645@              * Pointer 645
     LSDAAA    DCW  @I9G@              * Pointer I9G
     LFFAAA    DCW  @100000@           * Value 100000
     LOHAAA    DCW  @00010@            * Value 00010
     LBEAAA    DCW  @006@              * Pointer 006
     LOFAAA    DCW  @624@              * Pointer 624
     LHEAAA    DCW  @I9B@              * Pointer I9B
     LPGAAA    DCW  @727@              * Pointer 727
     LIFAAA    DCW  @604@              * Pointer 604
     LKGAAA    DCW  @660@              * Pointer 660
     LXDAAA    DCW  @00000@            * Value 00000
     LVDAAA    DCW  @00001@            * Value 00001
     LQGAAA    DCW  @734@              * Pointer 734
     LOGAAA    DCW  @720@              * Pointer 720
     LAFAAA    DCW  @I8F@              * Pointer I8F
     LPDAAA    DCW  @003@              * Pointer 003
     LSGAAA    DCW  @748@              * Pointer 748
     LXGAAA    DCW  @007@              * Pointer 007
     LPHAAA    DCW  @I9C@              * Pointer I9C
     LHFAAA    DCW  @00019@            * Value 00019
     LZDAAA    DCW  @605@              * Pointer 605
     LAGAAA    DCW  @ @                * Value  
     LIGAAA    DCW  @011@              * Pointer 011
     LBFAAA    DCW  @0000J@            * Value 0000J
     LGFAAA    DCW  @00042@            * Value 00042
     LGEAAA    DCW  @-@                * Value -
     LNHAAA    DCW  @D@                * Value D
     LUDAAA    DCW  @I9I@              * Pointer I9I
     LLGAAA    DCW  @699@              * Pointer 699
     LGGAAA    DCW  @00100@            * Value 00100
     LWGAAA    DCW  @I8I@              * Pointer I8I
     LCHAAA    DCW  @%@                * Value %
     LCGAAA    DCW  @201@              * Pointer 201
     LRGAAA    DCW  @741@              * Pointer 741
     LCFAAA    DCW  @008@              * Pointer 008
     LKEAAA    DCW  @0@                * Value 0
     LTGAAA    DCW  @755@              * Pointer 755
     LLFAAA    DCW  @I9D@              * Pointer I9D
     LKHAAA    DCW  @S@                * Value S
     LTDAAA    DCW  @001@              * Pointer 001
     LHGAAA    DCW  @690@              * Pointer 690
     LNGAAA    DCW  @713@              * Pointer 713
     LVGAAA    DCW  @769@              * Pointer 769
     LHHAAA    DCW  @C@                * Value C
     LWDAAA    DCW  @005@              * Pointer 005
     LBGAAA    DCW  @627@              * Pointer 627
     LAEAAA    DCW  @014@              * Pointer 014
     LUGAAA    DCW  @762@              * Pointer 762
     LYDAAA    DCW  @I9E@              * Pointer I9E
     LFGAAA    DCW  @333@              * Pointer 333

               END  START              * End of program code.
