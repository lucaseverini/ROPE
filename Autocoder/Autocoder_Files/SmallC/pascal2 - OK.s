     ****************************************************************
     ***  pascal2.s
     ***  Generated by Small-C Compiler on 22-Feb-2015 00:59:58
     ****************************************************************

     READ      EQU  001                * Read area
     PUNCH     EQU  101                * Punch area
     PRINT     EQU  201                * Print area
     
     PRCPOS    DCW  000                * char position in print area
     PUCPOS    DCW  000                * char position in punch area
     PUNSIZ    DCW  @080@              * Size of punch area
     PRTSIZ    DCW  @132@              * Size of print area
     EOS       DCW  @'@                * End Of String char
     EOL       DCW  @;@                * End Of Line char

               ORG  87
     X1        DSA  0                  * INDEX REGISTER 1
               ORG  92
     X2        DSA  0                  * INDEX REGISTER 2
               ORG  97
     X3        DSA  0                  * INDEX REGISTER 3
     
     * I need a single digit flag - should I replace this with a DA?
     RF        EQU  340
     
     ****************************************************************  

     * SET THE START POSITION OF CODE
               ORG  5500
               
     START     NOP  

     * SET THE STACK POINTER
               SBR  X2,400

               MCW  X2,X3
     *          LCA  LHCAAA,5005
     *          LCA  LICAAA,5025
     *          LCA  LJCAAA,5028
     *          LCA  LKCAAA,5033
               LCA  EOS,5022
               LCA  @F@,5021
               LCA  @E@,5020
               LCA  @D@,5019
               LCA  @C@,5018
               LCA  @B@,5017
               LCA  @A@,5016
               LCA  @9@,5015
               LCA  @8@,5014
               LCA  @7@,5013
               LCA  @6@,5012
               LCA  @5@,5011
               LCA  @4@,5010
               LCA  @3@,5009
               LCA  @2@,5008
               LCA  @1@,5007
               LCA  @0@,5006
               LCA  EOS,5040
               LCA  @C@,5039
               LCA  @%@,5038
               LCA  @D@,5037
               LCA  @%@,5036
               LCA  EOS,5077
               LCA  EOL,5076
               LCA  EOL,5075
               LCA  @S@,5074
               LCA  @N@,5073
               LCA  @O@,5072
               LCA  @I@,5071
               LCA  @T@,5070
               LCA  @A@,5069
               LCA  @R@,5068
               LCA  @E@,5067
               LCA  @T@,5066
               LCA  @I@,5065
               LCA  @ @,5064
               LCA  @D@,5063
               LCA  @%@,5062
               LCA  @ @,5061
               LCA  @H@,5060
               LCA  @T@,5059
               LCA  @I@,5058
               LCA  @W@,5057
               LCA  @ @,5056
               LCA  @E@,5055
               LCA  @L@,5054
               LCA  @G@,5053
               LCA  @N@,5052
               LCA  @A@,5051
               LCA  @I@,5050
               LCA  @R@,5049
               LCA  @T@,5048
               LCA  @ @,5047
               LCA  @L@,5046
               LCA  @A@,5045
               LCA  @C@,5044
               LCA  @S@,5043
               LCA  @A@,5042
               LCA  @P@,5041
               LCA  EOS,5085
               LCA  EOL,5084
               LCA  @.@,5083
               LCA  @E@,5082
               LCA  @N@,5081
               LCA  @O@,5080
               LCA  @D@,5079
               LCA  EOL,5078
               B    LBCAAA
               H    
     * FunctionDefinition((5))
     LFAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LGAAAA:null:8)
               LCA  LAFAAA,8+X3
               MA   LBFAAA,X2
     LCFAAA    NOP  
     * NotEqualExpression((str[(++len)]):'\0')
     * SubScriptEpression(str:(++len))
     * VariableExpression(str:-3:false)
     * Push(15997+X3:3)
               MA   LGFAAA,X2
               LCA  15997+X3,0+X2
     * PreIncrement(len)
     * Push(LBFAAA:3)
               MA   LGFAAA,X2
               LCA  LBFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
               A    LIFAAA,0+X1
     * Push(0+X1:5)
               MA   LJFAAA,X2
               LCA  0+X1,0+X2
     * raw index on the stack
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLFAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:1)
               MA   LSFAAA,X2
               LCA  0+X1,0+X2
     * ConstantExpression(0)
     * Push(EOS:1)
               MA   LSFAAA,X2
               LCA  EOS,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               BE   LEFAAA
               B    LFFAAA
     LEFAAA    MCW  LVFAAA,0+X2
     LFFAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LDFAAA,5+X2, 
               B    LCFAAA
     LDFAAA    NOP  
     * VariableExpression(len:8:false)
     * Push(8+X3:5)
               MA   LJFAAA,X2
               LCA  8+X3,0+X2
     * Pop(15994+X3:5)
               LCA  0+X2,15994+X3
               MA   LKFAAA,X2
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LGAAAA
     LGAAAA    NOP  
               MA   LWFAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((1))
     LBAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LCAAAA:null:3)
               MA   LGFAAA,X2
     * Assignment(seed=retree.expression.ModuloExpression@ee01430)
     * ModuloExpression(((42 * seed) + 19):100000)
     * ConstantExpression(100000)
     * Push(LXFAAA:5)
               MA   LJFAAA,X2
               LCA  LXFAAA,0+X2
     * Addition((42 * seed)+19)
     * Multiplication(42*seed)
     * ConstantExpression(42)
     * Push(LYFAAA:5)
               MA   LJFAAA,X2
               LCA  LYFAAA,0+X2
     * VariableExpression(seed:5005:true)
     * Push(5005:5)
               MA   LJFAAA,X2
               LCA  5005,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * ConstantExpression(19)
     * Push(LZFAAA:5)
               MA   LJFAAA,X2
               LCA  LZFAAA,0+X2
               A    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
               B    LAGAAA
     * Pop(5)
               MA   LKFAAA,X2
     * Push(LGGAAA:3)
               MA   LGFAAA,X2
               LCA  LGGAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LKFAAA,X2
     * VariableExpression(seed:5005:true)
     * Push(5005:5)
               MA   LJFAAA,X2
               LCA  5005,0+X2
     * Pop(15997+X3:5)
               LCA  0+X2,15997+X3
               MA   LKFAAA,X2
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LCAAAA
     LCAAAA    NOP  
               MA   LHFAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((15))
     LPAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LQAAAA:null:14)
               LCA  LHGAAA,9+X3
               LCA  LIFAAA,14+X3
               MA   LIGAAA,X2
     * Assignment(start=str)
     * VariableExpression(str:-8:false)
     * Push(15992+X3:3)
               MA   LGFAAA,X2
               LCA  15992+X3,0+X2
     * Push(LJGAAA:3)
               MA   LGFAAA,X2
               LCA  LJGAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHFAAA,X2
     * if(retree.statement.BlockStatement@279ac931:retree.statement.IfStatement@230ec447)
     * LessThanExpression(value:0)
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LJFAAA,X2
               LCA  15997+X3,0+X2
               B    LMGAAA
     * ConstantExpression(0)
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
               B    LMGAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
               MCW  LVFAAA,0+X2
               BL   LOGAAA
               B    LPGAAA
     LOGAAA    MCW  LIFAAA,0+X2
     LPGAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LKGAAA,5+X2, 
     * BlockStatement(LRAAAA:LQAAAA:0)
     * Assignment(( *(str++) )='-')
     * ConstantExpression(45)
     * Push(@-@:1)
               MA   LSFAAA,X2
               LCA  @-@,0+X2
     * PostIncrement(str)
     * Push(LWFAAA:3)
               MA   LGFAAA,X2
               LCA  LWFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
               MA   LSFAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUFAAA,X2
     * Assignment(value=(-value))
     * NegExpression(value)
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LJFAAA,X2
               LCA  15997+X3,0+X2
               ZS   0+X2
               B    LMGAAA
     * Push(LHFAAA:3)
               MA   LGFAAA,X2
               LCA  LHFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LKFAAA,X2
     LRAAAA    NOP  
               BCE  LQAAAA,RF,R
               B    LLGAAA
     LKGAAA    NOP  
     * if(retree.statement.BlockStatement@1e78234c:null)
     * EqualExpression(value:0)
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LJFAAA,X2
               LCA  15997+X3,0+X2
               B    LMGAAA
     * ConstantExpression(0)
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
               B    LMGAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
               BE   LSGAAA
               B    LTGAAA
     LSGAAA    MCW  LIFAAA,0+X2
     LTGAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LRGAAA,5+X2, 
     * BlockStatement(LSAAAA:LQAAAA:0)
     * Assignment((str[0])='0')
     * ConstantExpression(48)
     * Push(@0@:1)
               MA   LSFAAA,X2
               LCA  @0@,0+X2
     * VariableExpression(str:-8:false)
     * Push(15992+X3:3)
               MA   LGFAAA,X2
               LCA  15992+X3,0+X2
     * ConstantExpression(0)
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
     * raw index on the stack
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLFAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUFAAA,X2
     * Assignment((str[1])='\0')
     * ConstantExpression(0)
     * Push(EOS:1)
               MA   LSFAAA,X2
               LCA  EOS,0+X2
     * VariableExpression(str:-8:false)
     * Push(15992+X3:3)
               MA   LGFAAA,X2
               LCA  15992+X3,0+X2
     * ConstantExpression(1)
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
     * raw index on the stack
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLFAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUFAAA,X2
     * VariableExpression(start:6:false)
     * Push(6+X3:3)
               MA   LGFAAA,X2
               LCA  6+X3,0+X2
     * Pop(15984+X3:3)
               LCA  0+X2,15984+X3
               MA   LHFAAA,X2
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LSAAAA
     LSAAAA    NOP  
               BCE  LQAAAA,RF,R
     LRGAAA    NOP  
     LLGAAA    NOP  
     LVGAAA    NOP  
     * LessThanOrEqualExpression(exp:retree.expression.DivideExpression@61556234)
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LJFAAA,X2
               LCA  14+X3,0+X2
               B    LMGAAA
     * Divide(value/base)
     * VariableExpression(base:-11:false)
     * Push(15989+X3:5)
               MA   LJFAAA,X2
               LCA  15989+X3,0+X2
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LJFAAA,X2
               LCA  15997+X3,0+X2
               B    LAGAAA
               MCW  0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
               B    LMGAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
               MCW  LIFAAA,0+X2
               BH   LXGAAA
               B    LYGAAA
     LXGAAA    MCW  LVFAAA,0+X2
     LYGAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LWGAAA,5+X2, 
     * Assignment(exp=(exp * base))
     * Multiplication(exp*base)
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LJFAAA,X2
               LCA  14+X3,0+X2
     * VariableExpression(base:-11:false)
     * Push(15989+X3:5)
               MA   LJFAAA,X2
               LCA  15989+X3,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * Push(LIGAAA:3)
               MA   LGFAAA,X2
               LCA  LIGAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LKFAAA,X2
               B    LVGAAA
     LWGAAA    NOP  
     LZGAAA    NOP  
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LJFAAA,X2
               LCA  14+X3,0+X2
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LAHAAA,5+X2, 
     * BlockStatement(LTAAAA:LQAAAA:0)
     * Assignment(( *(str++) )=(digits[retree.expression.DivideExpression@5de6cecc]))
     * SubScriptEpression(digits:retree.expression.DivideExpression@5de6cecc)
     * VariableExpression(digits:9:false)
     * Push(9+X3:3)
               MA   LGFAAA,X2
               LCA  9+X3,0+X2
     * Divide(value/exp)
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LJFAAA,X2
               LCA  14+X3,0+X2
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LJFAAA,X2
               LCA  15997+X3,0+X2
               B    LAGAAA
               MCW  0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * raw index on the stack
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLFAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:1)
               MA   LSFAAA,X2
               LCA  0+X1,0+X2
     * PostIncrement(str)
     * Push(LWFAAA:3)
               MA   LGFAAA,X2
               LCA  LWFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
               MA   LSFAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUFAAA,X2
     * Assignment(value=retree.expression.ModuloExpression@5c12e33d)
     * ModuloExpression(value:exp)
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LJFAAA,X2
               LCA  14+X3,0+X2
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LJFAAA,X2
               LCA  15997+X3,0+X2
               B    LAGAAA
     * Pop(5)
               MA   LKFAAA,X2
     * Push(LHFAAA:3)
               MA   LGFAAA,X2
               LCA  LHFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LKFAAA,X2
     * Assignment(exp=retree.expression.DivideExpression@5c04e904)
     * Divide(exp/base)
     * VariableExpression(base:-11:false)
     * Push(15989+X3:5)
               MA   LJFAAA,X2
               LCA  15989+X3,0+X2
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LJFAAA,X2
               LCA  14+X3,0+X2
               B    LAGAAA
               MCW  0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * Push(LIGAAA:3)
               MA   LGFAAA,X2
               LCA  LIGAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LKFAAA,X2
     LTAAAA    NOP  
               BCE  LQAAAA,RF,R
               B    LZGAAA
     LAHAAA    NOP  
     * Assignment(( *str )='\0')
     * ConstantExpression(0)
     * Push(EOS:1)
               MA   LSFAAA,X2
               LCA  EOS,0+X2
     * VariableExpression(str:-8:false)
     * Push(15992+X3:3)
               MA   LGFAAA,X2
               LCA  15992+X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUFAAA,X2
     * VariableExpression(start:6:false)
     * Push(6+X3:3)
               MA   LGFAAA,X2
               LCA  6+X3,0+X2
     * Pop(15984+X3:3)
               LCA  0+X2,15984+X3
               MA   LHFAAA,X2
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LQAAAA
     LQAAAA    NOP  
               MA   LBHAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((36))
     LKBAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LLBAAA:null:7)
               MA   LCHAAA,X2
     * Assignment(arg=((*char) (( &cformat_str ) + (15997))))
     * Addition(( &cformat_str )+(15997))
     * AddressOfExpression(cformat_str)
     * Push(LHFAAA:3)
               MA   LGFAAA,X2
               LCA  LHFAAA,0+X2
               MA   X3,0+X2
     * ConstantExpression(15997)
     * Push(LHFAAA:3)
               MA   LGFAAA,X2
               LCA  LHFAAA,0+X2
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * Push(LJGAAA:3)
               MA   LGFAAA,X2
               LCA  LJGAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHFAAA,X2
     LDHAAA    NOP  
     * NotEqualExpression((c = ( *(cformat_str++) )):'\0')
     * Assignment(c=( *(cformat_str++) ))
     * DereferenceExpression((cformat_str++))
     * PostIncrement(cformat_str)
     * Push(LHFAAA:3)
               MA   LGFAAA,X2
               LCA  LHFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
               MA   LSFAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:1)
               MA   LSFAAA,X2
               LCA  0+X1,0+X2
     * Push(LCHAAA:3)
               MA   LGFAAA,X2
               LCA  LCHAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
               LCA  0+X2,0+X1
     * ConstantExpression(0)
     * Push(EOS:1)
               MA   LSFAAA,X2
               LCA  EOS,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               BE   LFHAAA
               B    LGHAAA
     LFHAAA    MCW  LVFAAA,0+X2
     LGHAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LEHAAA,5+X2, 
     * BlockStatement(LMBAAA:LLBAAA:0)
     * if(retree.statement.ExpressionStatement@52dce479:retree.statement.BlockStatement@241bee6f)
     * NotEqualExpression(c:'%')
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSFAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression(37)
     * Push(@%@:1)
               MA   LSFAAA,X2
               LCA  @%@,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               BE   LJHAAA
               B    LKHAAA
     LJHAAA    MCW  LVFAAA,0+X2
     LKHAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LHHAAA,5+X2, 
     * FunctionCallExpr((20))
     * Push(5)
               MA   LJFAAA,X2
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSFAAA,X2
               LCA  7+X3,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LUAAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
               B    LIHAAA
     LHHAAA    NOP  
     * BlockStatement(LNBAAA:LMBAAA:0)
     * Assignment(c=( *(cformat_str++) ))
     * DereferenceExpression((cformat_str++))
     * PostIncrement(cformat_str)
     * Push(LHFAAA:3)
               MA   LGFAAA,X2
               LCA  LHFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
               MA   LSFAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:1)
               MA   LSFAAA,X2
               LCA  0+X1,0+X2
     * Push(LCHAAA:3)
               MA   LGFAAA,X2
               LCA  LCHAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUFAAA,X2
     * if(retree.statement.BlockStatement@25c2cbee:retree.statement.IfStatement@17da89a0)
     * EqualExpression(c:'%')
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSFAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression(37)
     * Push(@%@:1)
               MA   LSFAAA,X2
               LCA  @%@,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
               BE   LOHAAA
               B    LPHAAA
     LOHAAA    MCW  LIFAAA,0+X2
     LPHAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LMHAAA,5+X2, 
     * BlockStatement(LOBAAA:LNBAAA:0)
     * FunctionCallExpr((20))
     * Push(5)
               MA   LJFAAA,X2
     * ConstantExpression(37)
     * Push(@%@:1)
               MA   LSFAAA,X2
               LCA  @%@,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LUAAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     LOBAAA    NOP  
               BCE  LNBAAA,RF,R
               B    LNHAAA
     LMHAAA    NOP  
     * if(retree.statement.BlockStatement@c81739c:retree.statement.IfStatement@6cd0d2e)
     * EqualExpression(c:'C')
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSFAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression(67)
     * Push(@C@:1)
               MA   LSFAAA,X2
               LCA  @C@,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
               BE   LSHAAA
               B    LTHAAA
     LSHAAA    MCW  LIFAAA,0+X2
     LTHAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LQHAAA,5+X2, 
     * BlockStatement(LPBAAA:LNBAAA:0)
     * FunctionCallExpr((20))
     * Push(5)
               MA   LJFAAA,X2
     * DereferenceExpression((arg--))
     * PostDecrement(arg)
     * Push(LJGAAA:3)
               MA   LGFAAA,X2
               LCA  LJGAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
               MA   LUFAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:1)
               MA   LSFAAA,X2
               LCA  0+X1,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LUAAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     LPBAAA    NOP  
               BCE  LNBAAA,RF,R
               B    LRHAAA
     LQHAAA    NOP  
     * if(retree.statement.BlockStatement@1c4a7f:retree.statement.IfStatement@415ed7e7)
     * EqualExpression(c:'S')
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSFAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression(83)
     * Push(@S@:1)
               MA   LSFAAA,X2
               LCA  @S@,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
               BE   LXHAAA
               B    LYHAAA
     LXHAAA    MCW  LIFAAA,0+X2
     LYHAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LVHAAA,5+X2, 
     * BlockStatement(LQBAAA:LNBAAA:0)
     * FunctionCallExpr((26))
     * Push(5)
               MA   LJFAAA,X2
     * DereferenceExpression(((**char) arg))
     * VariableExpression(arg:6:false)
     * Push(6+X3:3)
               MA   LGFAAA,X2
               LCA  6+X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LABAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * Assignment(arg=(arg + (15997)))
     * Addition(arg+(15997))
     * VariableExpression(arg:6:false)
     * Push(6+X3:3)
               MA   LGFAAA,X2
               LCA  6+X3,0+X2
     * ConstantExpression(15997)
     * Push(LHFAAA:3)
               MA   LGFAAA,X2
               LCA  LHFAAA,0+X2
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * Push(LJGAAA:3)
               MA   LGFAAA,X2
               LCA  LJGAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHFAAA,X2
     LQBAAA    NOP  
               BCE  LNBAAA,RF,R
               B    LWHAAA
     LVHAAA    NOP  
     * if(retree.statement.BlockStatement@39b0a038:retree.statement.ReturnStatement@7ae6da1e)
     * EqualExpression(c:'D')
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSFAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression(68)
     * Push(@D@:1)
               MA   LSFAAA,X2
               LCA  @D@,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
               BE   LCIAAA
               B    LDIAAA
     LCIAAA    MCW  LIFAAA,0+X2
     LDIAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LAIAAA,5+X2, 
     * BlockStatement(LRBAAA:LNBAAA:7)
               MA   LCHAAA,X2
     * FunctionCallExpr((15))
     * Push(3)
               MA   LGFAAA,X2
     * ConstantExpression(10)
     * Push(LFIAAA:5)
               MA   LJFAAA,X2
               LCA  LFIAAA,0+X2
     * ArrayNameExpresssion(a:char [7])
     * Push(LBFAAA:3)
               MA   LGFAAA,X2
               LCA  LBFAAA,0+X2
               MA   X3,0+X2
     * DereferenceExpression(((*int) arg))
     * VariableExpression(arg:6:false)
     * Push(6+X3:3)
               MA   LGFAAA,X2
               LCA  6+X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:5)
               MA   LJFAAA,X2
               LCA  0+X1,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LPAAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * FunctionCallExpr((26))
     * Push(5)
               MA   LJFAAA,X2
     * ArrayNameExpresssion(a:char [7])
     * Push(LBFAAA:3)
               MA   LGFAAA,X2
               LCA  LBFAAA,0+X2
               MA   X3,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LABAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * Assignment(arg=(arg + (15995)))
     * Addition(arg+(15995))
     * VariableExpression(arg:6:false)
     * Push(6+X3:3)
               MA   LGFAAA,X2
               LCA  6+X3,0+X2
     * ConstantExpression(15995)
     * Push(LKFAAA:3)
               MA   LGFAAA,X2
               LCA  LKFAAA,0+X2
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * Push(LJGAAA:3)
               MA   LGFAAA,X2
               LCA  LJGAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHFAAA,X2
     LRBAAA    NOP  
               MA   LGIAAA,X2
               BCE  LNBAAA,RF,R
               B    LBIAAA
     LAIAAA    NOP  
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LNBAAA
     LBIAAA    NOP  
     LWHAAA    NOP  
     LRHAAA    NOP  
     LNHAAA    NOP  
     LNBAAA    NOP  
               BCE  LMBAAA,RF,R
     LIHAAA    NOP  
     LMBAAA    NOP  
               BCE  LLBAAA,RF,R
               B    LDHAAA
     LEHAAA    NOP  
     LLBAAA    NOP  
               MA   LGIAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((20))
     LUAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LVAAAA:null:3)
               MA   LGFAAA,X2
     * if(retree.statement.BlockStatement@508a8b07:retree.statement.BlockStatement@37ada1e0)
     * NotEqualExpression(c:'\n')
     * VariableExpression(c:-3:false)
     * Push(15997+X3:1)
               MA   LSFAAA,X2
               LCA  15997+X3,0+X2
     * ConstantExpression(10)
     * Push(EOL:1)
               MA   LSFAAA,X2
               LCA  EOL,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               BE   LJIAAA
               B    LKIAAA
     LJIAAA    MCW  LVFAAA,0+X2
     LKIAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LHIAAA,5+X2, 
     * BlockStatement(LWAAAA:LVAAAA:0)
     * Assignment(( *(__putchar_pos++) )=c)
     * VariableExpression(c:-3:false)
     * Push(15997+X3:1)
               MA   LSFAAA,X2
               LCA  15997+X3,0+X2
     * PostIncrement(__putchar_pos)
     * Push(LMIAAA:3)
               MA   LGFAAA,X2
               LCA  LMIAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
               MA   LSFAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUFAAA,X2
     LWAAAA    NOP  
               BCE  LVAAAA,RF,R
               B    LIIAAA
     LHIAAA    NOP  
     * BlockStatement(LXAAAA:LVAAAA:0)
     LNIAAA    NOP  
     * GreaterThanOrEqualExpression(((int) __putchar_last):((int) __putchar_pos))
     * VariableExpression(__putchar_last:5028:true)
     * Push(5028:3)
               MA   LGFAAA,X2
               LCA  LB5028,0+X2
               B    LPIAAA
               B    LMGAAA
     * VariableExpression(__putchar_pos:5025:true)
     * Push(5025:3)
               MA   LGFAAA,X2
               LCA  LB5025,0+X2
               B    LPIAAA
               B    LMGAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
               MCW  LIFAAA,0+X2
               BL   LYIAAA
               B    LZIAAA
     LYIAAA    MCW  LVFAAA,0+X2
     LZIAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LOIAAA,5+X2, 
     * BlockStatement(LYAAAA:LXAAAA:0)
     * Assignment(( *(__putchar_last--) )=' ')
     * ConstantExpression(32)
     * Push(@ @:1)
               MA   LSFAAA,X2
               LCA  @ @,0+X2
     * PostDecrement(__putchar_last)
     * Push(LBJAAA:3)
               MA   LGFAAA,X2
               LCA  LBJAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
               MA   LUFAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUFAAA,X2
     LYAAAA    NOP  
               BCE  LXAAAA,RF,R
               B    LNIAAA
     LOIAAA    NOP  
     * Assignment(__putchar_last=__putchar_pos)
     * VariableExpression(__putchar_pos:5025:true)
     * Push(5025:3)
               MA   LGFAAA,X2
               LCA  LB5025,0+X2
     * Push(LBJAAA:3)
               MA   LGFAAA,X2
               LCA  LBJAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHFAAA,X2
     * Assignment(__putchar_pos=(201))
     * ConstantExpression(201)
     * Push(LICAAA:3)
               MA   LGFAAA,X2
               LCA  LICAAA,0+X2
     * Push(LMIAAA:3)
               MA   LGFAAA,X2
               LCA  LMIAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHFAAA,X2
     * Start asm block
               W    
     * End asm block
     LXAAAA    NOP  
               BCE  LVAAAA,RF,R
     LIIAAA    NOP  
     * if(retree.statement.BlockStatement@19b5080a:null)
     * EqualExpression(__putchar_pos:(333))
     * VariableExpression(__putchar_pos:5025:true)
     * Push(5025:3)
               MA   LGFAAA,X2
               LCA  LB5025,0+X2
     * ConstantExpression(333)
     * Push(LFJAAA:3)
               MA   LGFAAA,X2
               LCA  LFJAAA,0+X2
               C    0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
               BE   LDJAAA
               B    LEJAAA
     LDJAAA    MCW  LIFAAA,0+X2
     LEJAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LCJAAA,5+X2, 
     * BlockStatement(LZAAAA:LVAAAA:0)
     * Assignment(__putchar_last=__putchar_pos)
     * VariableExpression(__putchar_pos:5025:true)
     * Push(5025:3)
               MA   LGFAAA,X2
               LCA  LB5025,0+X2
     * Push(LBJAAA:3)
               MA   LGFAAA,X2
               LCA  LBJAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHFAAA,X2
     * Assignment(__putchar_pos=(201))
     * ConstantExpression(201)
     * Push(LICAAA:3)
               MA   LGFAAA,X2
               LCA  LICAAA,0+X2
     * Push(LMIAAA:3)
               MA   LGFAAA,X2
               LCA  LMIAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHFAAA,X2
     * Start asm block
               W    
     * End asm block
     LZAAAA    NOP  
               BCE  LVAAAA,RF,R
     LCJAAA    NOP  
     LVAAAA    NOP  
               MA   LHFAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((53))
     LBCAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LCCAAA:null:218)
               MA   LGJAAA,X2
     * ForStatement((i = 0),(i <= 20)'(i++):retree.statement.BlockStatement@3c22d5b5:LECAAA:LFCAAA:LGCAAA)
     * Assignment(i=0)
     * ConstantExpression(0)
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
     * Push(LGJAAA:3)
               MA   LGFAAA,X2
               LCA  LGJAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LKFAAA,X2
     LECAAA    NOP  
     * LessThanOrEqualExpression(i:20)
     * VariableExpression(i:218:false)
     * Push(218+X3:5)
               MA   LJFAAA,X2
               LCA  218+X3,0+X2
               B    LMGAAA
     * ConstantExpression(20)
     * Push(LHJAAA:5)
               MA   LJFAAA,X2
               LCA  LHJAAA,0+X2
               B    LMGAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
               MCW  LIFAAA,0+X2
               BH   LIJAAA
               B    LJJAAA
     LIJAAA    MCW  LVFAAA,0+X2
     LJJAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LFCAAA,5+X2, 
     * BlockStatement(LDCAAA:LCCAAA:0)
     * Assignment((x[i])=retree.expression.TernaryExpression@12fc7ceb)
     * TernaryExpression((i == 1):1:0)
     * EqualExpression(i:1)
     * VariableExpression(i:218:false)
     * Push(218+X3:5)
               MA   LJFAAA,X2
               LCA  218+X3,0+X2
               B    LMGAAA
     * ConstantExpression(1)
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               B    LMGAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
               BE   LMJAAA
               B    LNJAAA
     LMJAAA    MCW  LIFAAA,0+X2
     LNJAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LKJAAA,5+X2, 
     * ConstantExpression(1)
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               B    LLJAAA
     LKJAAA    NOP  
     * ConstantExpression(0)
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
     LLJAAA    NOP  
     * ArrayNameExpresssion(x:int [21])
     * Push(LBFAAA:3)
               MA   LGFAAA,X2
               LCA  LBFAAA,0+X2
               MA   X3,0+X2
     * VariableExpression(i:218:false)
     * Push(218+X3:5)
               MA   LJFAAA,X2
               LCA  218+X3,0+X2
     * raw index on the stack
     * Push(LOJAAA:5)
               MA   LJFAAA,X2
               LCA  LOJAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLFAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LKFAAA,X2
     * Assignment((y[i])=0)
     * ConstantExpression(0)
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
     * ArrayNameExpresssion(y:int [21])
     * Push(LPJAAA:3)
               MA   LGFAAA,X2
               LCA  LPJAAA,0+X2
               MA   X3,0+X2
     * VariableExpression(i:218:false)
     * Push(218+X3:5)
               MA   LJFAAA,X2
               LCA  218+X3,0+X2
     * raw index on the stack
     * Push(LOJAAA:5)
               MA   LJFAAA,X2
               LCA  LOJAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLFAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LKFAAA,X2
     LDCAAA    NOP  
               BCE  LCCAAA,RF,R
     LGCAAA    NOP  
     * PostIncrement(i)
     * Push(LGJAAA:3)
               MA   LGFAAA,X2
               LCA  LGJAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
               A    LIFAAA,0+X1
               B    LECAAA
     LFCAAA    NOP  
     * FunctionCallExpr((36))
     * Push(5)
               MA   LJFAAA,X2
     * ConstantExpression(20)
     * Push(LHJAAA:5)
               MA   LJFAAA,X2
               LCA  LHJAAA,0+X2
     * ArrayNameExpresssion("Pascal Triangle with %d iterations\n\n":char [37])
     * Push(LQJAAA:3)
               MA   LGFAAA,X2
               LCA  LQJAAA,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LKBAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * FunctionCallExpr((47))
     * Push(5)
               MA   LJFAAA,X2
     * ConstantExpression(0)
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
     * ArrayNameExpresssion(y:int [21])
     * Push(LPJAAA:3)
               MA   LGFAAA,X2
               LCA  LPJAAA,0+X2
               MA   X3,0+X2
     * ArrayNameExpresssion(x:int [21])
     * Push(LBFAAA:3)
               MA   LGFAAA,X2
               LCA  LBFAAA,0+X2
               MA   X3,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LVBAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * FunctionCallExpr((36))
     * Push(5)
               MA   LJFAAA,X2
     * ArrayNameExpresssion("\nDone.\n":char [8])
     * Push(LRJAAA:3)
               MA   LGFAAA,X2
               LCA  LRJAAA,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LKBAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     LCCAAA    NOP  
               MA   LSJAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((7))
     LHAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LIAAAA:null:3)
               MA   LGFAAA,X2
     LTJAAA    NOP  
     * NotEqualExpression((( *(dest++) ) = ( *(src++) )):'\0')
     * Assignment(( *(dest++) )=( *(src++) ))
     * DereferenceExpression((src++))
     * PostIncrement(src)
     * Push(LXJAAA:3)
               MA   LGFAAA,X2
               LCA  LXJAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
               MA   LSFAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:1)
               MA   LSFAAA,X2
               LCA  0+X1,0+X2
     * PostIncrement(dest)
     * Push(LHFAAA:3)
               MA   LGFAAA,X2
               LCA  LHFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
               MA   LSFAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
               LCA  0+X2,0+X1
     * ConstantExpression(0)
     * Push(EOS:1)
               MA   LSFAAA,X2
               LCA  EOS,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               BE   LVJAAA
               B    LWJAAA
     LVJAAA    MCW  LVFAAA,0+X2
     LWJAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LUJAAA,5+X2, 
               B    LTJAAA
     LUJAAA    NOP  
     LIAAAA    NOP  
               MA   LHFAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((47))
     LVBAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LWBAAA:null:14)
               MA   LIGAAA,X2
     * ForStatement((i = 1),(i < d)'(i++):retree.statement.BlockStatement@36496381:LYBAAA:LZBAAA:LACAAA)
     * Assignment(i=1)
     * ConstantExpression(1)
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
     * Push(LBFAAA:3)
               MA   LGFAAA,X2
               LCA  LBFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LKFAAA,X2
     LYBAAA    NOP  
     * LessThanExpression(i:d)
     * VariableExpression(i:8:false)
     * Push(8+X3:5)
               MA   LJFAAA,X2
               LCA  8+X3,0+X2
               B    LMGAAA
     * VariableExpression(d:-9:false)
     * Push(15991+X3:5)
               MA   LJFAAA,X2
               LCA  15991+X3,0+X2
               B    LMGAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
               MCW  LVFAAA,0+X2
               BL   LYJAAA
               B    LZJAAA
     LYJAAA    MCW  LIFAAA,0+X2
     LZJAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LZBAAA,5+X2, 
     * BlockStatement(LXBAAA:LWBAAA:0)
     * FunctionCallExpr((36))
     * Push(5)
               MA   LJFAAA,X2
     * TernaryExpression((i < (d - 1)):' ':'\n')
     * LessThanExpression(i:(d - 1))
     * VariableExpression(i:8:false)
     * Push(8+X3:5)
               MA   LJFAAA,X2
               LCA  8+X3,0+X2
               B    LMGAAA
     * Subtraction(d-1)
     * VariableExpression(d:-9:false)
     * Push(15991+X3:5)
               MA   LJFAAA,X2
               LCA  15991+X3,0+X2
     * ConstantExpression(1)
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               S    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
               B    LMGAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
               MCW  LVFAAA,0+X2
               BL   LCKAAA
               B    LDKAAA
     LCKAAA    MCW  LIFAAA,0+X2
     LDKAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LAKAAA,5+X2, 
     * ConstantExpression(32)
     * Push(@ @:1)
               MA   LSFAAA,X2
               LCA  @ @,0+X2
               B    LBKAAA
     LAKAAA    NOP  
     * ConstantExpression(10)
     * Push(EOL:1)
               MA   LSFAAA,X2
               LCA  EOL,0+X2
     LBKAAA    NOP  
     * Assignment((y[i])=((x[(i - 1)]) + (x[i])))
     * Addition((x[(i - 1)])+(x[i]))
     * SubScriptEpression(x:(i - 1))
     * VariableExpression(x:-3:false)
     * Push(15997+X3:3)
               MA   LGFAAA,X2
               LCA  15997+X3,0+X2
     * Subtraction(i-1)
     * VariableExpression(i:8:false)
     * Push(8+X3:5)
               MA   LJFAAA,X2
               LCA  8+X3,0+X2
     * ConstantExpression(1)
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               S    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * raw index on the stack
     * Push(LOJAAA:5)
               MA   LJFAAA,X2
               LCA  LOJAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLFAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:5)
               MA   LJFAAA,X2
               LCA  0+X1,0+X2
     * SubScriptEpression(x:i)
     * VariableExpression(x:-3:false)
     * Push(15997+X3:3)
               MA   LGFAAA,X2
               LCA  15997+X3,0+X2
     * VariableExpression(i:8:false)
     * Push(8+X3:5)
               MA   LJFAAA,X2
               LCA  8+X3,0+X2
     * raw index on the stack
     * Push(LOJAAA:5)
               MA   LJFAAA,X2
               LCA  LOJAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLFAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:5)
               MA   LJFAAA,X2
               LCA  0+X1,0+X2
               A    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * VariableExpression(y:-6:false)
     * Push(15994+X3:3)
               MA   LGFAAA,X2
               LCA  15994+X3,0+X2
     * VariableExpression(i:8:false)
     * Push(8+X3:5)
               MA   LJFAAA,X2
               LCA  8+X3,0+X2
     * raw index on the stack
     * Push(LOJAAA:5)
               MA   LJFAAA,X2
               LCA  LOJAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LLFAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHFAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
               LCA  0+X2,0+X1
     * ArrayNameExpresssion("%d%c":char [5])
     * Push(LEKAAA:3)
               MA   LGFAAA,X2
               LCA  LEKAAA,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LKBAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     LXBAAA    NOP  
               BCE  LWBAAA,RF,R
     LACAAA    NOP  
     * PostIncrement(i)
     * Push(LBFAAA:3)
               MA   LGFAAA,X2
               LCA  LBFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
               A    LIFAAA,0+X1
               B    LYBAAA
     LZBAAA    NOP  
     * TernaryExpression((20 >= d):(47( y x (d + 1))):0)
     * GreaterThanOrEqualExpression(20:d)
     * ConstantExpression(20)
     * Push(LHJAAA:5)
               MA   LJFAAA,X2
               LCA  LHJAAA,0+X2
               B    LMGAAA
     * VariableExpression(d:-9:false)
     * Push(15991+X3:5)
               MA   LJFAAA,X2
               LCA  15991+X3,0+X2
               B    LMGAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
               MCW  LIFAAA,0+X2
               BL   LHKAAA
               B    LIKAAA
     LHKAAA    MCW  LVFAAA,0+X2
     LIKAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LFKAAA,5+X2, 
     * FunctionCallExpr((47))
     * Push(5)
               MA   LJFAAA,X2
     * Addition(d+1)
     * VariableExpression(d:-9:false)
     * Push(15991+X3:5)
               MA   LJFAAA,X2
               LCA  15991+X3,0+X2
     * ConstantExpression(1)
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               A    0+X2,15995+X2
     * Pop(5)
               MA   LKFAAA,X2
     * VariableExpression(x:-3:false)
     * Push(15997+X3:3)
               MA   LGFAAA,X2
               LCA  15997+X3,0+X2
     * VariableExpression(y:-6:false)
     * Push(15994+X3:3)
               MA   LGFAAA,X2
               LCA  15994+X3,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LVBAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(3)
               MA   LHFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
               B    LGKAAA
     LFKAAA    NOP  
     * ConstantExpression(0)
     * Push(LVFAAA:5)
               MA   LJFAAA,X2
               LCA  LVFAAA,0+X2
     LGKAAA    NOP  
     * Pop(15986+X3:5)
               LCA  0+X2,15986+X3
               MA   LKFAAA,X2
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LWBAAA
     LWBAAA    NOP  
               MA   LBHAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((26))
     LABAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LBBAAA:null:3)
               MA   LGFAAA,X2
     LJKAAA    NOP  
     * NotEqualExpression(( *s ):'\0')
     * DereferenceExpression(s)
     * VariableExpression(s:-3:false)
     * Push(15997+X3:3)
               MA   LGFAAA,X2
               LCA  15997+X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:1)
               MA   LSFAAA,X2
               LCA  0+X1,0+X2
     * ConstantExpression(0)
     * Push(EOS:1)
               MA   LSFAAA,X2
               LCA  EOS,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Push(LIFAAA:5)
               MA   LJFAAA,X2
               LCA  LIFAAA,0+X2
               BE   LLKAAA
               B    LMKAAA
     LLKAAA    MCW  LVFAAA,0+X2
     LMKAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LKFAAA,X2
               BCE  LKKAAA,5+X2, 
     * BlockStatement(LCBAAA:LBBAAA:0)
     * FunctionCallExpr((20))
     * Push(5)
               MA   LJFAAA,X2
     * DereferenceExpression((s++))
     * PostIncrement(s)
     * Push(LHFAAA:3)
               MA   LGFAAA,X2
               LCA  LHFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:3)
               MA   LGFAAA,X2
               LCA  0+X1,0+X2
               MA   LSFAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHFAAA,X2
     * Push(0+X1:1)
               MA   LSFAAA,X2
               LCA  0+X1,0+X2
     * Push(X3:3)
               MA   LGFAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LUAAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHFAAA,X2
     * Pop(1)
               MA   LUFAAA,X2
     * Pop(5)
               MA   LKFAAA,X2
     LCBAAA    NOP  
               BCE  LBBAAA,RF,R
               B    LJKAAA
     LKKAAA    NOP  
     LBBAAA    NOP  
               MA   LHFAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     LMGAAA    SBR  X1
     * Normalizes the zone bits of a number, leaving either A=0B=0
     * for a positive or A=0B=1 for a negative
     * Do nothing on either no zone bits or only a b zone bit
               BWZ  LNGAAA,0+X2,2
               BWZ  LNGAAA,0+X2,K
     * else clear the zone bits, as it is positive
               MZ   @ @,0+X2
     LNGAAA    B    0+X1
    ****************************************************************  
    ** DIVISION SNIPPET                                           **
    ****************************************************************  
     
     LAGAAA    SBR  LBGAAA+3           * SETUP RETURN ADDRESS
     * POP DIVIDEND
               MCW  0+X2, LCGAAA
               SBR  X2, 15995+X2

     * POP DIVISOR
               MCW  0+X2, LDGAAA
               SBR  X2, 15995+X2


               B    *+17
               
               DCW  @00000@                
               DC   @00000000000@        

               ZA   LCGAAA, *-7         * PUT DIVIDEND INTO WORKING BL
               D    LDGAAA, *-19        * DIVIDE
               MZ   *-22, *-21          * KILL THE ZONE BIT
               MZ   *-29, *-34          * KILL THE ZONE BIT
               MCW  *-41, LEGAAA        * PICK UP ANSWER
               SW   *-44                * SO I CAN PICKUP REMAINDER
               MCW  *-46, LFGAAA        * GET REMAINDER
               CW   *-55                * CLEAR THE WM
               MZ   LEGAAA-1, LEGAAA    * CLEANUP QUOTIENT BITZONE
               MZ   LFGAAA-1, LFGAAA    * CLEANUP REMAINDER BITZONE
               
     * PUSH REMAINDER
               SBR  X2, 5+X2
               SW   15996+X2
               MCW  LFGAAA, 0+X2
               
     * PUSH QUOTIENT
               SBR  X2, 5+X2
               SW   15996+X2
               MCW  LEGAAA, 0+X2

     LBGAAA    B    000                 * JUMP BACK
               
     LDGAAA    DCW  00000               * DIVISOR
     LCGAAA    DCW  00000               * DIVIDEND
     LEGAAA    DCW  00000               * QUOTIENT
     LFGAAA    DCW  00000               * REMAINDER
     LLFAAA    SBR  X1
     * Casts a 5-digit number to a 3-digit address
     * make a copy of the top of the stack
               SW   15998+X2
               LCA  0+X2,3+X2
               CW   15998+X2
     * zero out the zone bits of our copy
               MZ   @0@,3+X2
               MZ   @0@,2+X2
               MZ   @0@,1+X2
     * set the low-order digit's zone bits
               C    @04000@,0+X2
               BL   LOFAAA
               C    @08000@,0+X2
               BL   LNFAAA
               C    @12000@,0+X2
               BL   LMFAAA
               S    @12000@,0+X2
               MZ   @A@,3+X2
               B    LOFAAA
     LMFAAA    S    @08000@,0+X2
               MZ   @I@,3+X2
               B    LOFAAA
     LNFAAA    S    @04000@,0+X2
               MZ   @S@,3+X2
     * For some reason the zone bits get set - it still works though.
     LOFAAA    C    @01000@,0+X2
               BL   LRFAAA
               C    @02000@,0+X2
               BL   LQFAAA
               C    @03000@,0+X2
               BL   LPFAAA
               MZ   @A@,1+X2
               B    LRFAAA
     LPFAAA    MZ   @I@,1+X2
               B    LRFAAA
     LQFAAA    MZ   @S@,1+X2
     LRFAAA    LCA  3+X2,15998+X2
               SBR  X2,15998+X2
               B    0+X1
     LPIAAA    SBR  X1
     * Casts a 3-digit address to a 5-digit number
     * Make room on the stack for an int
               MA   @002@,X2
     * make a copy of the top of the stack
               LCA  15998+X2,3+X2
     * Now zero out the top of the stack
               LCA  @00000@,0+X2
     * Now copy back, shifted over 2 digits
               MCW  3+X2,0+X2
     * Now zero out the zone bits on the stack
               MZ   @0@,0+X2
               MZ   @0@,15999+X2
               MZ   @0@,15998+X2
     * check the high-order digit's zone bits
               BWZ  LQIAAA,1+X2,S
               BWZ  LRIAAA,1+X2,K
               BWZ  LSIAAA,1+X2,B
               B    LTIAAA
     LQIAAA    A    @01000@,0+X2
               B    LTIAAA
     LRIAAA    A    @02000@,0+X2
               B    LTIAAA
     LSIAAA    A    @03000@,0+X2
     LTIAAA    BWZ  LUIAAA,3+X2,S
               BWZ  LVIAAA,3+X2,K
               BWZ  LWIAAA,3+X2,B
               B    LXIAAA
     LUIAAA    A    @04000@,0+X2
               B    LXIAAA
     LVIAAA    A    @08000@,0+X2
               B    LXIAAA
     LWIAAA    A    @12000@,0+X2
     LXIAAA    B    0+X1
     
     * REMEMBER THAT ORG LOCATION IS VARSIZE-1 LOCATION BEFORE
     * IF INT VAR (5 DIGITS) IS AT 1000 THEN ITS ORG MUST BE 996 (1000 - (5 - 1)) 
               ORG  5001               * 5005
     LB5005    DCW  @69105@
               ORG  5023               * 5025 - 5028
     LB5025    DCW  @201@
     LB5028    DCW  @200@
               ORG  5031               * 5033
     LB5033    DCW  @081@

     * SET THE START POSITION OF DATA
               ORG  4000

     LAJAAA    DCW  @ @
     LHFAAA    DCW  @I9G@
     LAFAAA    DCW  @0000J@
     LHCAAA    DCW  @69105@
     LXFAAA    DCW  @100000@
     LSJAAA    DCW  @G8B@
     LYFAAA    DCW  @00042@
     LQGAAA    DCW  @-@
     LEIAAA    DCW  @D@
     LUFAAA    DCW  @I9I@
     LRJAAA    DCW  @'7Y@
     LHGAAA    DCW  @'0W@
     LMIAAA    DCW  @'2V@
     LFIAAA    DCW  @00010@
     LLHAAA    DCW  @%@
     LPJAAA    DCW  @113@
     LJGAAA    DCW  @006@
     LICAAA    DCW  @201@
     LBFAAA    DCW  @008@
     LUGAAA    DCW  @0@
     LKCAAA    DCW  @081@
     LWFAAA    DCW  @I9B@
     LXJAAA    DCW  @I9D@
     LZHAAA    DCW  @S@
     LVFAAA    DCW  @00000@
     LSFAAA    DCW  @001@
     LIFAAA    DCW  @00001@
     LEKAAA    DCW  @'3W@
     LLIAAA    DCW  EOL
     LGJAAA    DCW  @218@
     LUHAAA    DCW  @C@
     LBHAAA    DCW  @I8F@
     LGFAAA    DCW  @003@
     LGGAAA    DCW  @'0V@
     LOJAAA    DCW  @00005@
     LJFAAA    DCW  @005@
     LTFAAA    DCW  EOS
     LBJAAA    DCW  @'2Y@
     LHJAAA    DCW  @00020@
     LCHAAA    DCW  @007@
     LQJAAA    DCW  @'4/@
     LJCAAA    DCW  @200@
     LIGAAA    DCW  @014@
     LGIAAA    DCW  @I9C@
     LKFAAA    DCW  @I9E@
     LZFAAA    DCW  @00019@
     LFJAAA    DCW  @333@
     

               END  START
