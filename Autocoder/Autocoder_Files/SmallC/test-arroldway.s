     ****************************************************************
     ***  test.s
     ***  Generated by Small-C Compiler on 24-Mar-2015 1:52:54 PM
     ****************************************************************
     ****************************************************************

     READ      EQU  001                * Read area
     PUNCH     EQU  101                * Punch area
     PRINT     EQU  201                * Print area
     
     PRCPOS    DCW  000                * char position in print area
     PUCPOS    DCW  000                * char position in punch area
     PUNSIZ    DCW  @080@              * Size of punch area
     PRTSIZ    DCW  @132@              * Size of print area
     EOS       DCW  @'@                * End Of String char
     EOL       DCW  @;@                * End Of Line char

               ORG  87
     X1        DSA  0                  * INDEX REGISTER 1
               ORG  92
     X2        DSA  0                  * INDEX REGISTER 2
               ORG  97
     X3        DSA  0                  * INDEX REGISTER 3
     
     * I need a single digit flag - should I replace this with a DA?
     RF        EQU  340
     
     ****************************************************************
     
     * SET THE START POSITION OF VARIABLES INITIALIZATION DATA

     * SET THE START POSITION OF CODE
               ORG  600
     START     NOP                     * Program starts here

     * SET THE STACK POINTER (STACK GROWS UPWARD)
               SBR  X2,399             * X2 is the stack pointer
               MCW  X2,X3              * Copy X2 to X3

               B    LBAAAA             * Jump to function main
               H                       * Program executed. System halted.

     ********************************************************************************
     * Function : main
     ********************************************************************************
     LBAAAA    SBR  3+X3               * Save return address in register B to local frame
               SW   1+X3               * Set the WM
               CW   2+X3               * Clean WM
               CW   3+X3               * Clean WM

     ***************************************
     * BeginBlock [Block LCAAAA:null]
               MA   LDAAAA,X2          * Reserve 53 bytes of space on Stack
     * Assignment ((a[0]) = 1)
     * Constant (1 : LEAAAA)
     * Push (LEAAAA:5)
               MA   LFAAAA,X2          * Add 5 to X2
               LCA  LEAAAA,0+X2        * Load data 00001 into Stack

     * SubScript (a[0])
     * Local Array (a:int [10])
     * Push (LGAAAA:3)
               MA   LHAAAA,X2          * Add 3 to X2
               LCA  LGAAAA,0+X2        * Load data 008 into Stack
               MA   X3,0+X2
     * Constant (0 : LIAAAA)
     * Push (LIAAAA:5)
               MA   LFAAAA,X2          * Add 5 to X2
               LCA  LIAAAA,0+X2        * Load data 00000 into Stack
     * Put raw index on the stack
     * Push (LJAAAA:5)
               MA   LFAAAA,X2          * Add 5 to X2
               LCA  LJAAAA,0+X2        * Load data 00005 into Stack
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LKAAAA,X2          * Add -5 to X2
     * Stack top is now array index
               B    LLAAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LSAAAA,X2          * Add -3 to X2
     * Stack top is location in array now
     * End SubScript (a[0])

     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LSAAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LKAAAA,X2          * Add -5 to X2
     * Assignment ((a[1]) = 2)
     * Constant (2 : LTAAAA)
     * Push (LTAAAA:5)
               MA   LFAAAA,X2          * Add 5 to X2
               LCA  LTAAAA,0+X2        * Load data 00002 into Stack

     * SubScript (a[1])
     * Local Array (a:int [10])
     * Push (LGAAAA:3)
               MA   LHAAAA,X2          * Add 3 to X2
               LCA  LGAAAA,0+X2        * Load data 008 into Stack
               MA   X3,0+X2
     * Constant (1 : LEAAAA)
     * Push (LEAAAA:5)
               MA   LFAAAA,X2          * Add 5 to X2
               LCA  LEAAAA,0+X2        * Load data 00001 into Stack
     * Put raw index on the stack
     * Push (LJAAAA:5)
               MA   LFAAAA,X2          * Add 5 to X2
               LCA  LJAAAA,0+X2        * Load data 00005 into Stack
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop (5)
               MA   LKAAAA,X2          * Add -5 to X2
     * Stack top is now array index
               B    LLAAAA             * Jump to snippet number_to_pointer
               MA   0+X2,15997+X2
     * Pop (3)
               MA   LSAAAA,X2          * Add -3 to X2
     * Stack top is location in array now
     * End SubScript (a[1])

     * Pop (X1:3)
               LCA  0+X2,X1            * Load data in Stack into memory at X1
               MA   LSAAAA,X2          * Add -3 to X2
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load data in Stack into memory at 0+X1
               MA   LKAAAA,X2          * Add -5 to X2
     LCAAAA    NOP                     * Return
               MA   LUAAAA,X2          * Reserve 53 bytes of space on Stack
               MCW  @ @,RF             * Clear the Return Flag
     * EndBlock [Block LCAAAA:null]
     ***************************************

               LCA  3+X3,X1            * Load return address to X1
               B    0+X1               * Jump back to caller

     ********************************************************************************
     * End Function : main
     ********************************************************************************
     ****************************************************************
     ** CAST NUMBER TO POINTER SNIPPET                             **
     ****************************************************************
     LLAAAA    SBR  X1
     * Casts a 5-digit number to a 3-digit address
     * make a copy of the top of the stack
               SW   15998+X2
               LCA  0+X2,3+X2
               CW   15998+X2
     * zero out the zone bits of our copy
               MZ   @0@,3+X2
               MZ   @0@,2+X2
               MZ   @0@,1+X2
     * set the low-order digit's zone bits
               C    @04000@,0+X2
               BL   LOAAAA
               C    @08000@,0+X2
               BL   LNAAAA
               C    @12000@,0+X2
               BL   LMAAAA
               S    @12000@,0+X2
               MZ   @A@,3+X2
               B    LOAAAA
     LMAAAA    S    @08000@,0+X2
               MZ   @I@,3+X2
               B    LOAAAA
     LNAAAA    S    @04000@,0+X2
               MZ   @S@,3+X2
     * For some reason the zone bits get set - it still works though.
     LOAAAA    C    @01000@,0+X2
               BL   LRAAAA
               C    @02000@,0+X2
               BL   LQAAAA
               C    @03000@,0+X2
               BL   LPAAAA
               MZ   @A@,1+X2
               B    LRAAAA
     LPAAAA    MZ   @I@,1+X2
               B    LRAAAA
     LQAAAA    MZ   @S@,1+X2
     LRAAAA    LCA  3+X2,15998+X2
               SBR  X2,15998+X2
               B    0+X1
               
     ****************************************************************
     

     LUAAAA    DCW  @I4G@              * Pointer 0
     LSAAAA    DCW  @I9G@              * Pointer 0
     LEAAAA    DCW  @00001@            * Value 00001
     LGAAAA    DCW  @008@              * Pointer 0
     LDAAAA    DCW  @053@              * Pointer 0
     LKAAAA    DCW  @I9E@              * Pointer 0
     LTAAAA    DCW  @00002@            * Value 00002
     LHAAAA    DCW  @003@              * Pointer 0
     LJAAAA    DCW  @00005@            * Value 00005
     LIAAAA    DCW  @00000@            * Value 00000
     LFAAAA    DCW  @005@              * Pointer 0

               END  START              * End of program code.
